<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>coding | 瑟瑟和你说早安</title>
    <link>https://blog.morningtzh.com/categories/coding/</link>
      <atom:link href="https://blog.morningtzh.com/categories/coding/index.xml" rel="self" type="application/rss+xml" />
    <description>coding</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>zh-Hans</language><copyright>©MorningTZH</copyright><lastBuildDate>Tue, 29 Oct 2019 15:50:50 +0800</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>coding</title>
      <link>https://blog.morningtzh.com/categories/coding/</link>
    </image>
    
    <item>
      <title>boost.asio核心浅析</title>
      <link>https://blog.morningtzh.com/post/boost.asio%E6%A0%B8%E5%BF%83%E6%B5%85%E6%9E%90/</link>
      <pubDate>Tue, 29 Oct 2019 15:50:50 +0800</pubDate>
      <guid>https://blog.morningtzh.com/post/boost.asio%E6%A0%B8%E5%BF%83%E6%B5%85%E6%9E%90/</guid>
      <description>&lt;h1 id=&#34;boostasio核心浅析&#34;&gt;boost.asio核心浅析&lt;/h1&gt;
&lt;!-- @import &#34;[TOC]&#34; {cmd=&#34;toc&#34; depthFrom=1 depthTo=6 orderedList=false} --&gt;
</description>
    </item>
    
    <item>
      <title>C&#43;&#43;公共模块回调函数实现方式</title>
      <link>https://blog.morningtzh.com/post/c&#43;&#43;%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Thu, 05 Sep 2019 11:40:07 +0800</pubDate>
      <guid>https://blog.morningtzh.com/post/c&#43;&#43;%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</guid>
      <description>&lt;h1 id=&#34;c公共模块回调函数实现方式&#34;&gt;C++公共模块回调函数实现方式&lt;/h1&gt;
&lt;!-- @import &#34;[TOC]&#34; {cmd=&#34;toc&#34; depthFrom=1 depthTo=6 orderedList=false} --&gt;
&lt;p&gt;在代码实现时，常常会遇到模块间函数调用的问题。对于一个公共模块，会有明确的public方法来作为接口，但是当需要发送消息（此处仅讨论回调函数）到外部业务模块的时候就很难去定义回调函数的类型。通常在命令式编程中会采用函数指针的方法，但在OO中调用者是一个类的话很难将类成员函数发给基础模块做回调函数。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1-传统函数指针回调&#34;&gt;1. 传统函数指针回调&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>devstack安装镜像</title>
      <link>https://blog.morningtzh.com/post/devstack-install-tips/</link>
      <pubDate>Tue, 20 Sep 2016 19:30:14 +0000</pubDate>
      <guid>https://blog.morningtzh.com/post/devstack-install-tips/</guid>
      <description>&lt;h1 id=&#34;devstack安装镜像&#34;&gt;devstack安装镜像&lt;/h1&gt;
&lt;h2 id=&#34;pip镜像&#34;&gt;pip镜像：&lt;/h2&gt;
&lt;p&gt;pip 镜像我使用清华大学的，在可信列表（
&lt;a href=&#34;www.douban.com&#34;&gt;豆瓣&lt;/a&gt;的可坑死啦，不在信任列表，安装会跳问题：豆瓣源『http://pypi.douban.com/simple』）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In file &amp;ldquo;~/.pip/pip.conf&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;[global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;ubuntu-apt-镜像&#34;&gt;Ubuntu Apt 镜像&lt;/h2&gt;
&lt;p&gt;apt镜像反正看你喜欢咯！！！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In file &amp;ldquo;/etc/apt/sources.list&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;openstack@openstack
deb &lt;a href=&#34;http://mirrors.aliyun.com/ubuntu/&#34;&gt;http://mirrors.aliyun.com/ubuntu/&lt;/a&gt; trusty main restricted universe multiverse
deb &lt;a href=&#34;http://mirrors.aliyun.com/ubuntu/&#34;&gt;http://mirrors.aliyun.com/ubuntu/&lt;/a&gt; trusty-security main restricted universe m
ultiverse
deb &lt;a href=&#34;http://mirrors.aliyun.com/ubuntu/&#34;&gt;http://mirrors.aliyun.com/ubuntu/&lt;/a&gt; trusty-updates main restricted universe mu
ltiverse
deb &lt;a href=&#34;http://mirrors.aliyun.com/ubuntu/&#34;&gt;http://mirrors.aliyun.com/ubuntu/&lt;/a&gt; trusty-proposed main restricted universe m
ultiverse
deb &lt;a href=&#34;http://mirrors.aliyun.com/ubuntu/&#34;&gt;http://mirrors.aliyun.com/ubuntu/&lt;/a&gt; trusty-backports main restricted universe
multiverse
deb-src &lt;a href=&#34;http://mirrors.aliyun.com/ubuntu/&#34;&gt;http://mirrors.aliyun.com/ubuntu/&lt;/a&gt; trusty main restricted universe multiv
erse
deb-src &lt;a href=&#34;http://mirrors.aliyun.com/ubuntu/&#34;&gt;http://mirrors.aliyun.com/ubuntu/&lt;/a&gt; trusty-security main restricted univer
se multiverse
deb-src &lt;a href=&#34;http://mirrors.aliyun.com/ubuntu/&#34;&gt;http://mirrors.aliyun.com/ubuntu/&lt;/a&gt; trusty-updates main restricted univers
e multiverse
deb-src &lt;a href=&#34;http://mirrors.aliyun.com/ubuntu/&#34;&gt;http://mirrors.aliyun.com/ubuntu/&lt;/a&gt; trusty-proposed main restricted univer
se multiverse
deb-src &lt;a href=&#34;http://mirrors.aliyun.com/ubuntu/&#34;&gt;http://mirrors.aliyun.com/ubuntu/&lt;/a&gt; trusty-backports main restricted unive
rse multiverse&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
## openstack git 镜像

In file ?/local.conf (官网并没说丢在哪里。。。我就 devstack 文件夹和用户主目录都丢了个)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;[[local|localrc]]
ADMIN_PASSWORD=openstack
DATABASE_PASSWORD=$ADMIN_PASSWORD
RABBIT_PASSWORD=$ADMIN_PASSWORD
SERVICE_PASSWORD=$ADMIN_PASSWORD&lt;/p&gt;
&lt;p&gt;# Define images to be automatically downloaded during the DevStack built process.
DOWNLOAD_DEFAULT_IMAGES=False
IMAGE_URLS=&amp;quot;http://download.cirros-cloud.net/0.3.4/cirros-0.3.4-x86_64-disk.img&amp;rdquo;&lt;/p&gt;
&lt;p&gt;#change github to trystack
GIT_BASE=${GIT_BASE:-http://git.trystack.cn}
NOVNC_REPO=${NOVNC_REPO:-http://git.trystack.cn/kanaka/noVNC.git}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
这个镜像下载速度我家 20M 水管，下载速度为600+kiB/s

## 小问题
pypi 包更新的时候（~/devstack/file/get-pip.py文件）很容易断，我直接手机[GoodReader](https://itunes.apple.com/us/app/goodreader/id777310222?mt=8)下载好后，再电脑用 GoodReader 上的地址下的，速度很快。

虚拟机内存1G 不够！！！会报错！！！

哇靠。。。我电脑反正玩不来了，虚拟机给了2g 交换空间1g 全部占满，难怪听说要4g 内存。我还是光看看代码吧

其他的安装就按 devstack 官网就行了


&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Brainfuck解释器[on python]</title>
      <link>https://blog.morningtzh.com/post/brainfuck-interpreter/</link>
      <pubDate>Sat, 05 Dec 2015 21:43:14 +0000</pubDate>
      <guid>https://blog.morningtzh.com/post/brainfuck-interpreter/</guid>
      <description>&lt;p&gt;阿婆主脑容量不够，ぜんぜん不能在大脑中运行 &lt;strong&gt;Brainfuck&lt;/strong&gt; 程序，而且发现连运行过程都想不出来啊，
然而就这么几个字符完全可以自己写解释器嘛，并且可以打印出运行过程，而且可以试试看做成playground
的形式呢，想想还是挺有趣的。&lt;/p&gt;
&lt;p&gt;项目地址：
&lt;a href=&#34;https://code.csdn.net/u012822586/brainfuck_interpreter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Code CSDN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Git地址：
&lt;a href=&#34;git://code.csdn.net/u012822586/brainfuck_interpreter.git&#34;&gt;Git on CSDN&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;brainfuck&#34;&gt;Brainfuck&lt;/h2&gt;
&lt;p&gt;Brainfuck是一种图灵完备的语言，他可以做到任何事情，他的编译器是世界上最小的，他共有8个操作符：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Operator&lt;/th&gt;
&lt;th&gt;Function&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;increment the data pointer (to point to the next cell to the right).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;decrement the data pointer (to point to the next cell to the left).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;+&lt;/td&gt;
&lt;td&gt;increment (increase by one) the byte at the data pointer.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td&gt;decrement (decrease by one) the byte at the data pointer.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;.&lt;/td&gt;
&lt;td&gt;output the byte at the data pointer.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;,&lt;/td&gt;
&lt;td&gt;accept one byte of input, storing its value in the byte at the data pointer.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;[&lt;/td&gt;
&lt;td&gt;if the byte at the data pointer is zero, then instead of moving the instruction pointer forward to the next command, jump it forward to the command after the matching &lt;strong&gt;]&lt;/strong&gt; command.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;]&lt;/td&gt;
&lt;td&gt;if the byte at the data pointer is nonzero, then instead of moving the instruction pointer forward to the next command, jump it back to the command after the matching &lt;strong&gt;[&lt;/strong&gt; command.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;基本就是对内存直接操作的语言，他的『Hello World!』是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;++++++++[&amp;gt;++++[&amp;gt;++&amp;gt;+++&amp;gt;+++&amp;gt;+&amp;laquo;&amp;laquo;-]&amp;gt;+&amp;gt;+&amp;gt;-&amp;raquo;+[&amp;lt;]&amp;lt;-]&amp;raquo;.&amp;gt;&amp;mdash;.+++++++..+++.&amp;raquo;.&amp;lt;-.&amp;lt;.+++.&amp;mdash;&amp;mdash;.&amp;mdash;&amp;mdash;&amp;ndash;.&amp;raquo;+.&amp;gt;++.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;WTF!!!!!!&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;需求点&#34;&gt;需求点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1、基本功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解释裸BF程序&lt;/li&gt;
&lt;li&gt;打印内存信息&lt;/li&gt;
&lt;li&gt;分开输出以及集体输出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2、调试功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置断点&lt;/li&gt;
&lt;li&gt;单步执行&lt;/li&gt;
&lt;li&gt;查看内存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3、playground功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;做命令行模式（加参数可选）&lt;/li&gt;
&lt;li&gt;窗口分割&lt;/li&gt;
&lt;li&gt;实时解释&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基本功能实现&#34;&gt;基本功能实现&lt;/h2&gt;
&lt;p&gt;Brainfuck基本解释使用class BF()来实现&lt;/p&gt;
&lt;h3 id=&#34;数据部分&#34;&gt;数据部分&lt;/h3&gt;
&lt;p&gt;class BF()中数据由两部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Brainfuck程序&lt;/li&gt;
&lt;li&gt;内存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BF直接对内存进行操作，所以这边可以很简单的用list模拟出来，这样我们就有了一个无限长的内存，并用&lt;em&gt;&lt;strong&gt;BF.position&lt;/strong&gt;&lt;/em&gt;来指明正在操作的内存，相当于一个指针（实际是list index）。另外一个就是代码存储区，代码由&lt;strong&gt;string&lt;/strong&gt;类型的&lt;em&gt;&lt;strong&gt;BF.code&lt;/strong&gt;&lt;/em&gt;保存，同样有个代码指针&lt;em&gt;&lt;strong&gt;BF.codePosition&lt;/strong&gt;&lt;/em&gt;指明目前正在解释的操作符.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def __init__(self):
	self.codeInit()
	self.ifRuntime = True
	
def memoryInit(self):
	self.dirty = False     # if memory have been wroten
	self.memory = [0]      # memory
	self.position = 0      # pointer to memory which byte now operating
	self.codePosition = 0  # pointer to code which operator now parsing
	self.result = &#39;&#39;       # store whole program output
	
def codeInit(self, code = None):
	if None == code:       # for object init without BF code
	    self.code = &#39;&#39;
	
	self.code = code
	self.memoryInit()

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;操作符动作&#34;&gt;操作符动作&lt;/h3&gt;
&lt;p&gt;操作符没有一点难度,按照wiki来解释。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def getChar(self):
    return self.memory[self.position]

&#39;&#39;&#39;operators&#39;&#39;&#39;
def printChar(self):
    print &amp;quot;echo: &amp;quot;,
    print chr(self.memory[self.position])    # turn to ASCII char
    self.result += chr(self.memory[self.position])  # store output
def inputChar(self):
    print &amp;quot;put in: &amp;quot;,
    self.memory[self.position] = ord(sys.stdin.read(1))
def increment(self):
    self.memory[self.position] += 1
def decrement(self):
    self.memory[self.position] -= 1
def next(self):
    self.position += 1
    if len(self.memory) &amp;lt;= self.position:
        self.memory.append(0)
def previous(self):
    self.position -= 1
    if 0 &amp;gt; self.position:
        print &#39;error: position is %d&#39;%self.position
        print printMemory()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;循环实现&#34;&gt;循环实现&lt;/h3&gt;
&lt;p&gt;循环实现比较麻烦，本来只简单地想到一对括号的情况，后面发现了多对括号的问题，就先使用&lt;strong&gt;direction&lt;/strong&gt;来保存括号在代码中的位子。并且用&lt;strong&gt;stack&lt;/strong&gt;来先记录左括号。&lt;/p&gt;
&lt;p&gt;首先在&lt;strong&gt;&lt;em&gt;loopParser()&lt;em&gt;&lt;strong&gt;中记录成对的括号位置，同时意味着循环开始结束地址也被记录了下来。在这个函数中，首先使用&lt;/strong&gt;stack&lt;/em&gt;&lt;/em&gt;来登记未配对左括号地址，并在出现右括号时，弹出一个左括号地址，与右括号地址配对，写入&lt;/strong&gt;&lt;em&gt;loopMap&lt;/em&gt;&lt;strong&gt;这个&lt;/strong&gt;direction**中，同样这个地址配对记录需要返回给主解析流程的。&lt;/p&gt;
&lt;p&gt;在主流程中，通过&lt;em&gt;&lt;strong&gt;loopParser()&lt;em&gt;&lt;strong&gt;获得&lt;/strong&gt;&lt;/em&gt;loopMap&lt;/strong&gt;&lt;/em&gt;后,就开始对整个BF代码进行解释。此时根据wiki中的操作符作用，遇到**[**时检查当前指针内容是否为0，为0则不进入循环，直接跳到对应的**]**地址上，遇到**]**时，当前指针内容不为0，则跳回到对应**[**代码地址，继续循环。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def loopParser(self, code):
    &#39;&#39;&#39;parse loop operator, recode the position of code&#39;&#39;&#39;
    loopMap = {}
    leftStack = []
    codePosition = 0
    leftNum = 0
    rightNum = 0
    for operator in code:
        if operator == &#39;[&#39;:
            leftStack.append(codePosition)
            leftNum += 1
        elif operator == &#39;]&#39;:
            leftPosition = leftStack.pop()
            rightPosition = codePosition
            loopMap[leftPosition] = rightPosition
            loopMap[rightPosition] = leftPosition
            rightNum += 1
        codePosition += 1

    if 0 != len(leftStack):
        print &amp;quot;error: there are %d &#39;[&#39; but %d &#39;]&#39;&amp;quot;
        loopMap = None

    return loopMap


def parser(self, code = None):
    &#39;&#39;&#39;parse code&#39;&#39;&#39;
    if None == code:
        code = self.code
        self.memoryInit()

    loopMap = self.loopParser(code)
    if None == loopMap:
        return

    if None == code:
        code = self.code

    while self.codePosition &amp;lt; len(code):
        operator = code[self.codePosition]
        if operator == &amp;quot;&amp;gt;&amp;quot;:
            self.next()
        elif operator == &amp;quot;&amp;lt;&amp;quot;:
            self.previous()
        elif operator == &amp;quot;+&amp;quot;:
            self.increment()
        elif operator == &amp;quot;-&amp;quot;:
            self.decrement()
        elif operator == &amp;quot;.&amp;quot;:
            self.printChar()
        elif operator == &amp;quot;,&amp;quot;:
            self.inputChar()
        elif operator == &amp;quot;[&amp;quot; and self.getChar() == 0:
            self.codePosition = loopMap[self.codePosition]
        elif operator == &amp;quot;]&amp;quot; and self.getChar() != 0:
            self.codePosition = loopMap[self.codePosition]
        self.runtime()
        self.codePosition += 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;打印runtime&#34;&gt;打印runtime&lt;/h3&gt;
&lt;p&gt;做这个解释器的主要原因就是，看不懂Brainfuck每一步为什么要这样做，所以解释器的重点就在于打印每一步的数据内存和代码内存，并且标出目前运行到哪里了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Global function:

	def printChar(char, point = False):
		if point:
		    char = &#39;\033[31m%s\033[0m&#39; %char  # print red chars on Unix
		
		sys.stdout.write(char + &#39; &#39;)


BF() method:

    def printData(self, data, position):
        &#39;&#39;&#39;print linear data and point the position now point&#39;&#39;&#39;
        point = False
        for nowPosition in xrange(0, len(data)):
            if nowPosition == position:
                point = True

            printChar(str(data[nowPosition]), point)
            point = False
        print &amp;quot;&amp;quot;                 # printChar don&#39;t print &#39;\n&#39;

    def runtime(self):
        &#39;&#39;&#39;print runtime memory and code&#39;&#39;&#39;
        if self.ifRuntime:
            self.printData(self.code, self.codePosition)
            self.printData(self.memory, self.position)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;基本功能运行结果&#34;&gt;基本功能运行结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://7xrczi.com1.z0.glb.clouddn.com/image/BFinterpreter/brainfuck_interpreter.jpg.tiff&#34; alt=&#34;BFinterpreter运行结果&#34;&gt;&lt;/p&gt;
&lt;p&gt;未完待续。。。或者。。。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Install GHC on El Capitan</title>
      <link>https://blog.morningtzh.com/post/install-ghc-on-mac/</link>
      <pubDate>Sat, 05 Dec 2015 21:43:14 +0000</pubDate>
      <guid>https://blog.morningtzh.com/post/install-ghc-on-mac/</guid>
      <description>&lt;hr&gt;
&lt;p&gt;最近因为在学Haskell，所以需要在电脑上安装GHC，然而遇到了一些困难，所以需要做一下记录。&lt;/p&gt;
&lt;p&gt;##安装GHC##
首先GHC安装，其实这并不需要从brew安装的，我们可以从
&lt;a href=&#34;https://ghcformacosx.github.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;官网&lt;/a&gt;找到OSX的app，下载就好.当然上面很坑爹的写了一句：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Requirements&lt;/strong&gt;&lt;br&gt;
Only tested on 64-bit Mac OS X 10.10&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好吧好吧，这个免责协议我认。。。&lt;/p&gt;
&lt;p&gt;下载下来就按照官网上的提示安装就好，拖到 &lt;em&gt;&lt;strong&gt;/Application&lt;/strong&gt;&lt;/em&gt;&amp;hellip;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Download and unzip ghc-7.10.2-r0.zip (193MB)&lt;/li&gt;
&lt;li&gt;Move it to a stable location such as /Applications&lt;/li&gt;
&lt;li&gt;Double-click for instructions to install Xcode and add it to your Terminal&amp;rsquo;s $PATH&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一个坑爹的来了，app会说建立 &lt;em&gt;&lt;strong&gt;~/.zshenv&lt;/strong&gt;&lt;/em&gt; 并将环境变量脚本自动拷贝进去，然而在实际使用中似乎 &lt;em&gt;&lt;strong&gt;~/.zshenv&lt;/strong&gt;&lt;/em&gt; 并没有在使用，我并不是很了解zsh还有这个文件，并且实际操作无效，所以我还是将它放进了 &lt;em&gt;&lt;strong&gt;~/.zshrc&lt;/strong&gt;&lt;/em&gt; 中，当然是有效的。&lt;/p&gt;
&lt;p&gt;##使用cabal##
在El Capitan中使用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;➜  Haskell git:(master) ✗ cabal install cabal-install&lt;br&gt;
cabal: /usr/bin/ar: permission denied&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;会发现 &lt;em&gt;&lt;strong&gt;权限不够！！！！&lt;/strong&gt;&lt;/em&gt; WTF&lt;/p&gt;
&lt;p&gt;好吧。。。找了半天。好吧我找的有错误。。。在
&lt;a href=&#34;http://stackoverflow.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Stack Overflow&lt;/a&gt;中找 &lt;em&gt;&lt;strong&gt;[haskell]el capitan&lt;/strong&gt;&lt;/em&gt; 才能完美的找到解决方案！！！（好吧，其实我也知道是El Capitan的Rootless模式，只是在寻找其他解决方案而已）
在 
&lt;a href=&#34;http://stackoverflow.com/questions/33452396/haskell-for-mac-el-capitan&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Haskell for Mac (El Capitan)&lt;/a&gt;中指出，需要关闭 &lt;em&gt;&lt;strong&gt;Rootless&lt;/strong&gt;&lt;/em&gt; ：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;重启，使用 &lt;em&gt;&lt;strong&gt;CMD+R&lt;/strong&gt;&lt;/em&gt; 进入recover模式&lt;br&gt;
在终端中输入 &lt;em&gt;&lt;strong&gt;csrutil disable&lt;/strong&gt;&lt;/em&gt; 关闭Rootless模式，并重启&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样再使用cabal install就不会有权限问题了~&lt;/p&gt;
&lt;p&gt;当然El Capitan的Rootless是新开发的强有力对抗入侵的方式，Rootless使能后，即使root用户也无权对核心文件进行修改和执行。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>关于haskell随便写点什么1</title>
      <link>https://blog.morningtzh.com/post/about-haskell-1/</link>
      <pubDate>Sat, 07 Nov 2015 23:22:35 +0800</pubDate>
      <guid>https://blog.morningtzh.com/post/about-haskell-1/</guid>
      <description>&lt;h1 id=&#34;lyah字典查询函数理解指南&#34;&gt;LYAH字典查询函数理解指南&lt;/h1&gt;
&lt;h3 id=&#34;for-what-&#34;&gt;for what&lt;/h3&gt;
&lt;p&gt;最近在看Haskell，并且极度想要给好基友安利这一个语言。So，今天看
&lt;a href=&#34;http://learnyouahaskell.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;《Learn You a Haskell for Great Good》&lt;/a&gt;恰巧基友被我安利烦了，问我haskell有什么好的，我刚看到§7.4 Data.Map这章，就发了看到的第一个函数给他，不过感觉他会看不懂，就想写个讲解给他，写长了之后就想成文了。&lt;/p&gt;
&lt;h3 id=&#34;那个函数&#34;&gt;那个函数&lt;/h3&gt;
&lt;p&gt;这是一个从字典中找值的函数&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;findKey :: (Eq k) =&amp;gt; k -&amp;gt; [(k,v)] -&amp;gt; v&lt;br&gt;
findKey key xs = snd . head . filter (\(k,v) -&amp;gt; key == k) $ xs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;举个栗子&#34;&gt;举个栗子&lt;/h3&gt;
&lt;p&gt;这个例子同样是从LYAH中搞出来的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;phoneBook = [(&amp;ldquo;betty&amp;rdquo;,&amp;ldquo;555-2938&amp;rdquo;) ,
      (&amp;ldquo;bonnie&amp;rdquo;,&amp;ldquo;452-2928&amp;rdquo;) , &lt;br&gt;
      (&amp;ldquo;patsy&amp;rdquo;,&amp;ldquo;493-2928&amp;rdquo;) ,&lt;br&gt;
      (&amp;ldquo;lucille&amp;rdquo;,&amp;ldquo;205-2928&amp;rdquo;) ,&lt;br&gt;
      (&amp;ldquo;wendy&amp;rdquo;,&amp;ldquo;939-8282&amp;rdquo;) ,&lt;br&gt;
      (&amp;ldquo;penny&amp;rdquo;,&amp;ldquo;853-2492&amp;rdquo;) ]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;函数申明&#34;&gt;函数申明&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;findKey :: (Eq k) =&amp;gt; k -&amp;gt; [(k,v)] -&amp;gt; v&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在函数中，首先第一行是函数申明，他和其他语言一样表明了输入输出。&lt;br&gt;
在haskell中函数仅支持一个返回值，支持多个入参。在上面的申明中 &lt;strong&gt;findKey&lt;/strong&gt; 是函数名，以 &amp;ldquo;&lt;strong&gt;::&lt;/strong&gt;&amp;ldquo;来标明函数，后面一共有四个东西，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(Eq k) =&amp;gt; k -&amp;gt; [(k,v)] -&amp;gt; v&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先可以仅理解后三个：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;k -&amp;gt; [(k,v)] -&amp;gt; v&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是函数参数和返回值，这个函数中一共有两个参数和一个返回值，函数申明中的最后一个箭头&amp;rdquo;&lt;strong&gt;-&amp;gt;&lt;/strong&gt;&amp;ldquo;是一定指向返回值的，当然&amp;rdquo;&lt;strong&gt;k v&lt;/strong&gt;&amp;ldquo;这两个字母一定会让人觉得很疑惑，在haskell中函数声明中的字母其实只代表一个&lt;del&gt;变量类型&lt;/del&gt;哦 sorry，haskell中没有变量，他只有常量，所有都是静态参数，所以这个字母代表了一种模糊的参数类型，这仅表示上面两个k需要是同样的类型，而两个v也需要是同样的类型，随便用abcd也可以。所以：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;rdquo;&lt;strong&gt;k&lt;/strong&gt;&amp;rdquo; &amp;ldquo;&lt;strong&gt;[(k,v)]&lt;/strong&gt;&amp;rdquo; 是两个入参，第一个参数是k类型的参数，第二个参数是一个list，list中是一个有两个类型为k v为成员的tuple&lt;/p&gt;
&lt;p&gt;&amp;rdquo;&lt;strong&gt;v&lt;/strong&gt;&amp;rdquo; 是函数的返回值，它的类型需要和入参list中tuple第二个元素一样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后我们来说一说&amp;rdquo;&lt;strong&gt;(Eq k) =&amp;gt;&lt;/strong&gt;&amp;quot;, &amp;ldquo;&lt;strong&gt;=&amp;gt;&lt;/strong&gt;&amp;ldquo;是对后面参数的约束条件，&amp;quot;&lt;strong&gt;(Eq k)&lt;/strong&gt;&amp;ldquo;说明后面的 &amp;ldquo;&lt;strong&gt;k&lt;/strong&gt;&amp;rdquo; 类型的参数必须是一个Eq的派生类型，这种类型是可以比较的，比如int，char。&lt;/p&gt;
&lt;p&gt;在事例中我们可以按照&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;findKey &amp;ldquo;betty&amp;rdquo; phoneBook&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;的方式进行调用，其中phoneBook可扩展成的[(&amp;ldquo;betty&amp;rdquo;,&amp;ldquo;555-2938&amp;rdquo;)&amp;hellip;]，看起来形式就差不多了。&lt;/p&gt;
&lt;h3 id=&#34;函数实体&#34;&gt;函数实体&lt;/h3&gt;
&lt;h4 id=&#34;函数调用&#34;&gt;函数调用&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;findKey key xs = snd . head . filter (\(k,v) -&amp;gt; key == k) $ xs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是函数体，在等号左边的是函数调用的方式，在这个函数中，调用方式是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;findKey key xs&lt;br&gt;
example:&lt;em&gt;&lt;strong&gt;findKey &amp;ldquo;betty&amp;rdquo; phoneBook&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然也可以是中序，这个就另讲了。这个函数调用方式也是一种模式匹配，这边的&amp;rdquo;&lt;strong&gt;key&lt;/strong&gt;&amp;quot;、&amp;quot;&lt;strong&gt;xs&lt;/strong&gt;&amp;ldquo;匹配了函数的两个入参&amp;rdquo;&lt;strong&gt;k&lt;/strong&gt;&amp;quot;、&amp;quot;&lt;strong&gt;[(k,v)]&lt;/strong&gt;&amp;rdquo;&lt;/p&gt;
&lt;h4 id=&#34;filter&#34;&gt;filter&lt;/h4&gt;
&lt;p&gt;接下来对这两个入参进行操作(先忽略&amp;rdquo;&lt;strong&gt;$&lt;/strong&gt;&amp;ldquo;符号)：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;filter (\(k,v) -&amp;gt; key == k) xs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先是filter，这个是对一个list的过滤器，是&amp;rdquo;&lt;strong&gt;filter &lt;em&gt;f&lt;/em&gt; list&lt;/strong&gt;&amp;rdquo; 这样的模式，对list的每一个元素使用函数&lt;em&gt;&lt;strong&gt;f&lt;/strong&gt;&lt;/em&gt;进行匹配。在此例中&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(\(k,v) -&amp;gt; key == k)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就是filter中的 &lt;em&gt;&lt;strong&gt;f&lt;/strong&gt;&lt;/em&gt; ，haskell中使用 \做lambda，lambda就是一个隐式函数。&lt;br&gt;
在lambda中&amp;rdquo;&lt;strong&gt;-&amp;gt;&lt;/strong&gt;&amp;ldquo;是用来区分参数和lambda函数本体的，在&amp;rdquo;&lt;strong&gt;-&amp;gt;&lt;/strong&gt;&amp;ldquo;左边是函数参数，可做模式匹配。在此lambda函数中，用&amp;rdquo;&lt;strong&gt;(k,v)&lt;/strong&gt;&amp;ldquo;来匹配list成员tuple的成员。第一个&amp;rdquo;&lt;strong&gt;(k,v)&lt;/strong&gt;&amp;ldquo;就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;(&amp;ldquo;betty&amp;rdquo;,&amp;ldquo;555-2938&amp;rdquo;)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此lambda用来匹配 xs 这个list取出来的每一个元组，并且判断此元组中的键值 k 是否能匹配入参的 key。并且filter会将符合条件的元素==重新组合==成一个新的list，在此例中，filter结果就是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;[(&amp;ldquo;betty&amp;rdquo;,&amp;ldquo;555-2938&amp;rdquo;)]&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;后面键值不为***&amp;ldquo;betty&amp;rdquo;***的元组就会被舍弃，这是仅有一个元素的list。&lt;/p&gt;
&lt;h4 id=&#34;snd-head&#34;&gt;snd head&lt;/h4&gt;
&lt;p&gt;接下来这个是head，这个函数用来取list的头部，取出来就是第一个元素，例如&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;***head [3,2,5,3,6,3,4,3,7]***的结果就是3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在此例中结果大致是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;(&amp;ldquo;betty&amp;rdquo;,&amp;ldquo;555-2938&amp;rdquo;)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是的，你会发现，这仅仅是去掉了中括号，这代表着这不再是一个list了。&lt;/p&gt;
&lt;p&gt;接下来snd用来取tuple中的第二个元素，就是字典中的value，也就是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;&amp;ldquo;555-2938&amp;rdquo;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就能得出函数返回值了。这边需要注意的是，snd的参数只能是二元tuple。&lt;/p&gt;
&lt;h4 id=&#34;函数组合&#34;&gt;函数组合&lt;/h4&gt;
&lt;p&gt;snd . head . filter 这个是函数组合，相当于一下子调用了三个函数。这个可以用数学公式来表示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(f.g)(x) = f(g(x))&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在此处&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;snd.head.filter f $ list = snd(head(filter f list)))&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在haskell中，函数组合是一个让代码简洁明了的手段，但是他也有它的局限性，就是说他的参数只能唯一，函数组合仅能包含一个参数。但是此处柯里化使得组合函数使用多参成为可能。&lt;/p&gt;
&lt;h4 id=&#34;柯里化currying&#34;&gt;柯里化（Currying）&lt;/h4&gt;
&lt;p&gt;柯里化是现代化语言中包含的一个非常有趣的特性之一，在js、swift中也支持柯里化（非常遗憾swift仅在Language Reference中提到了一点）。&lt;br&gt;
Currying是指函数可以不完全调用，他可以将多参函数转化为单参函数来求解。例如&amp;rdquo;&lt;strong&gt;+&lt;/strong&gt;&amp;ldquo;函数（对，在haskell中&amp;rdquo;&lt;strong&gt;+&lt;/strong&gt;&amp;ldquo;也是一个函数）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;5+4&lt;/strong&gt;&lt;/em&gt;   =======&amp;gt;  &lt;em&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其可以转化为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;let plusFive = (+5)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样一来我们就多了一个新的函数叫做&lt;em&gt;&lt;strong&gt;plusFive&lt;/strong&gt;&lt;/em&gt;，我们来调用它：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;plusFive 4&lt;/strong&gt;&lt;/em&gt;   =======&amp;gt;   &lt;em&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;&lt;strong&gt;plusFive 167&lt;/strong&gt;&lt;/em&gt; =======&amp;gt;   &lt;em&gt;&lt;strong&gt;172&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ok，Currying就是这样一个好玩的特性，我自己认为，这个和惰性有关，因为Curried Function切切实实要在有完整入参时才会调用。&lt;/p&gt;
&lt;p&gt;对于本例来说，我们将&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;filter (\(k,v) -&amp;gt; key == k) xs&lt;/strong&gt;&lt;/em&gt; Currying成
***(filter (\(k,v) -&amp;gt; key == k)) xs***&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在组合函数中其实是组合成了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;***(snd . head . filter (\(k,v) -&amp;gt; key == k)) xs***&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在原函数中，少了&amp;rdquo;&lt;strong&gt;()&lt;/strong&gt;&amp;quot;,多了&amp;rdquo;&lt;strong&gt;$&lt;/strong&gt;&amp;quot;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;snd . head . filter (\(k,v) -&amp;gt; key == k) $ xs&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这边用到了的&amp;rdquo;&lt;strong&gt;$&lt;/strong&gt;&amp;quot;,如果缺少&amp;rdquo;&lt;strong&gt;$&lt;/strong&gt;&amp;rdquo;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;snd . head . filter (\(k,v) -&amp;gt; key == k) xs&lt;/strong&gt;&lt;/em&gt; 会被理解成&lt;br&gt;
&lt;em&gt;&lt;strong&gt;snd . head . (filter (\(k,v) -&amp;gt; key == k) xs)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而这绝对是会被编译器理解不能的句子，会报错，&amp;quot;&lt;strong&gt;$&lt;/strong&gt;&amp;ldquo;改变了&lt;em&gt;&lt;strong&gt;filter&lt;/strong&gt;&lt;/em&gt;函数的匹配方式，在haskell中&amp;rdquo;&lt;strong&gt;$&lt;/strong&gt;&amp;ldquo;是拥有最低优先级的函数调用符，相当于一个函数，所以会变成&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;snd . head . filter (\(k,v) -&amp;gt; key == k) ($ xs)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;函数组合的优先级大于&lt;em&gt;&lt;strong&gt;$ xs&lt;/strong&gt;&lt;/em&gt;的优先级，就会前面线组合起来。&amp;quot;&lt;strong&gt;$&lt;/strong&gt;&amp;ldquo;是一个非常节约括号的函数调用符.&lt;/p&gt;
&lt;h3 id=&#34;函数结论&#34;&gt;函数结论&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;findKey &amp;ldquo;betty&amp;rdquo; phoneBook&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
***&amp;ldquo;555-2938&amp;rdquo;***&lt;br&gt;
***findKey &amp;ldquo;patsy&amp;rdquo; phoneBook***&lt;br&gt;
***&amp;ldquo;493-2928&amp;rdquo;***&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就此结束吧，心血来潮谢谢，先打上个标签1，说不定还有2，3，4&amp;hellip;呢，也或许会太监了呢。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
