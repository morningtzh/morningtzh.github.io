[{"authors":["admin"],"categories":null,"content":"叮！这是一个非常混乱的站点，全是 XJB 乱写的文章（没错！很多都只写了一半！\n甚至连主题都还没设定好。哦！我太菜了！\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"zh","lastmod":-62135596800,"objectID":"38823022532afb073b52a7bca40a5f32","permalink":"/authors/morningtzh/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/morningtzh/","section":"authors","summary":"叮！这是一个非常混乱的站点，全是 XJB 乱写的文章（没错！很多都只写了一半！ 甚至连主题都还没设定好。哦！我太菜了！","tags":null,"title":"MorningTZH","type":"authors"},{"authors":["Friend"],"categories":null,"content":"Never give up!\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"zh","lastmod":-62135596800,"objectID":"694bc8e345806718ca76dc5263e1d6eb","permalink":"/authors/tardis/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/tardis/","section":"authors","summary":"Never give up!","tags":null,"title":"Eric","type":"authors"},{"authors":["Friend"],"categories":null,"content":"一个瞎折腾活在楚门世界的小菜鸡\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"zh","lastmod":-62135596800,"objectID":"56e8354ab0b24b4f935adea7f6d6ed9f","permalink":"/authors/yunxia/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/yunxia/","section":"authors","summary":"一个瞎折腾活在楚门世界的小菜鸡","tags":null,"title":"404 Not Found","type":"authors"},{"authors":null,"categories":["职场"],"content":"创业公司经历 [TOC]\n在初创企业工作，是一件在职业道路中有正式规划的事情，也是一件意料之外的事情。没想到这段经历来的如此之快，但仔细一想这短短的经历几乎占据了我工龄的一半时间。\n在初创企业工作会面临比大厂更广泛的挑战。也能推动着学习更多的知识——大部分只会在自己成立公司时会用到，这些知识在符合个人发展需求时会飞快的融入到自身素养当中。\n独当一面的技术 在最初建立技术积累时会发现是完全从零开始的，得益于在原先公司业余时的技术积累，能快速理解，并选择当前状况下最好的技术方案。初创公司的基础决定了无法有健全的技术体系，需要根据业务做即时的调整，并且需要有前瞻性来保证做好了应对未来需求变化时不需要做较大的改动。每个新增功能尽量做增量型改动，这需要基本模块做到『低耦合高内聚』和『小而美』。\n研发人员需要对前沿技术有更多地了解，对不同技术领域的知识均有涉猎。虽然我是做 C 语言发开的，但是对前后端开发人员都能进行一些基本知识的指导，能讨论相应的技术解决方案。这个技能来源于用心学习，一个是自己做过相应技术的项目（无论是工作中或是业余项目），能 cover 住需求所需的技术要点即可；第二点是在实操中了解技术原理，从官方文档中去学习，反复推敲实现方案；第三点挺重要的，需要知道大家平时遇见的问题，并知道解决过程，即使是别人解决掉的问题也成为了自己的经验。\n最后被人的评价就是\u0026hellip;怎么什么都懂。当然啦，太多深入的技术知识我也能就不太了解了。\n管理知识 在我的观点中，进入初创公司，就需要把自己当成主人，如此才能获得更多经验来支撑未来的发展。在初创企业中，公司为了节约成本往往会将职能部门的hc预算放的很低（有时候技术部门都未免其难），行政、人力资源会招非专业的人员以降低成本。但企业实际的需求是需要更专业的人员来为企业量身制定规则，非专业人员无法有效的开展工作，会变成打杂人员。\n在这一矛盾下，企业实际管理者就需要有较高的素养了，对行政、管理、人力资源、财务等方面有一定的知识积累，才能带领公司发展。抛开预算和专业性的矛盾来说，如果管理者缺乏相关知识，即使招到了专家，也无法将其很好的利用起来。此处分两面说，当老板放权的情况下，专家缺乏对公司的了解，老板需要用一定的专业术语来描述公司状况，否则将会迎来很长的震荡阶段；另一方面老板不放权，那更需要通过一定的专业知识来指导专家做执行工作，否则可能导致南辕北辙。\n股权及一级市场投资 初创企业不可避免的会涉及到股权方面的问题，这是在初创企业打工所必备的知识，直接关系到劳动者的利益。这也是在进入初创企业时老板画的大饼。\n需要了解到的大致有：\n 注册资金 实缴和认缴 货币出资和非货币出资（技术入股） 股权转让方式 一级市场和二级市场 资本公积 股权溢价 公司类型（有限责任公司、合伙公司、股份公司） 合伙公司中的 GP、LP AB 股 破产清算 退出机制 VC/PE/FOF 股份变现方式和阶段 IPO（\u0026lt;\u0026ndash;太高级了，一点不懂）  这些知识了解后就会发现一些公司给出的股份可能有坑。例如公司在未实缴注册资金的情况下股权转让给员工，而后进行了天使轮投资，此时资方会要求所有股东实缴注册资金，那员工可能需要按比例出钱哦~\n这里面的门门道道太多了，以至于离职是老板面谈四五次用股份来挽留我也被我拒绝了。有空的时候可以将之前了解到的知识整理出来。\n管理者必备的素质 在工作过程中，体会到了创业如履薄冰，需要考究的事项太多。\n创始人的人格将会引导公司文化 首先要说明的是在和一些资方及高管交流的过程中，我们得出了一个结论：『创始人的人格会极大的影响公司文化』，这也应证了『小公司的发展看老板，中型公司发展看制度，大公司发展看文化』这句话。小公司的文化即老板个人人格的外显，会深刻的影响整个公司的发展。\n我们也曾私下讨论过一些问题，诸如当创始人能力不佳时资本方会逐渐加入管理，但是否能彻底将创始人边缘化的问题。对于这个问题我认为创始人在前期是无法被边缘化的，除了利益方面的问题，还有文化方面的。当创始人被边缘化后，消除其能力不佳对公司造成的影响的同时也会将公司的整个文化和所有的理念清洗掉，这将会从根本上泯灭一家公司的灵魂。\n因此创始人需要有一定的高度后创办一家公司的幸存率才会高。\n创始团队与社招 在公司经历一定发展后，将不满足于现有的规模，开始进行社招。初创团队往往会不舍得去招人，尤其在技术公司中，人员成本是公司开支的大头。当公司决定以低于市场价的标准招人，且没有其他吸引人的优势时就会引发一系列严重的问题。\n初创公司在招人方面往往有以下一些劣势：\n 工资没有吸引力 公司无行业影响力，甚至无人知晓 福利待遇低于相对成熟的公司 制度不完善 招聘方式不佳 招聘投入过低  这导致了初创公司只能在沙子中筛选金子，这个成本是巨大的，而且很难淘到金子，只会获得一团散沙。水向低处流，人往高处走，除非是一起参与公司创立的创始团队，很少会有精英选择加入一家短期收益低微，长期收益渺茫的初创公司。这也是创始团队和社招的区别所在。\n创始团队不易得，在我所经历的公司中，创始团队是创始人多次邀请邀请来的，其中的沟通成本是非常大的。创始团队的维持依托于后续公司良好的发展及获得长期收益的希望。经历过成熟企业和精英训练的创始团队拥有一定的见识和知识水平，能在一定程度上分辨公司的靠谱程度，以画饼招募到的创始团队无法以画饼维持，需要创始人通过务实的努力来维持创始团队的信心。\n社招不易得。创始团队可以通过创始人人格魅力来获得较高的性价比，但社招应聘人员往往考量的是实际获得的收入，在面试短短的一小时内，人格的吸引力还无法发挥作用。因此上文提到了获得创始团队的沟通成本是巨大的，这包含了展现人格魅力的时间。在实际收入较低时，便很难招到优秀的人，甚至很难找到优秀的应届生。同样在招到优秀的人才后如果降低人员流失率就是和创始团队一样的问题了。\n以上总总难处导致了初创企业人员配置不佳，\n信守承诺 完善流程制度 精细控制，对公司负责 信息控制 逻辑自洽 换位思考 员工情绪 ","date":1575369007,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1575369007,"objectID":"b6ce6b5b7bbe1bd80536b1669c7c2fe6","permalink":"/post/%E5%88%9B%E4%B8%9A%E5%85%AC%E5%8F%B8%E7%BB%8F%E5%8E%86/","publishdate":"2019-12-03T18:30:07+08:00","relpermalink":"/post/%E5%88%9B%E4%B8%9A%E5%85%AC%E5%8F%B8%E7%BB%8F%E5%8E%86/","section":"post","summary":"创业公司经历 [TOC] 在初创企业工作，是一件在职业道路中有正式规划的事情，也是一件意料之外的事情。没想到这段经历来的如此之快，但仔细一想这短短的经历","tags":["工作"],"title":"创业公司经历","type":"post"},{"authors":null,"categories":["深度学习"],"content":"线性回归及实现 [TOC]\n一年多前，《修真聊天群》更新看完了，在书荒引发的无聊情绪推动下学习了 Keras，用 LSTM 生成了大段无法看的《伪*修真聊天群》，没有耐心好好炼丹就没有再接触过深度学习的知识点，偶尔无聊看看聚宽上的文章也都是随机森林和隐马尔科夫模型等传统机器学习算法。 近期 gayhub 上榜了一个 《TensorFlow 2.0深度学习开源书》，正巧之后的新工作也与 TensorFlow 有些许关联，就趁机学习一下。\n看了教程打算手撸下公式推导及函数实现。（ \u0026lt;\u0026ndash; 抄袭狗 ）\n1.线性回归  线性回归是利用数理统计中回归分析，来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法，运用十分广泛。其表达形式为y = w\u0026rsquo;x+e，e为误差服从均值为0的正态分布。 \u0026mdash;- 百度百科\n 1.1 二元一次方程 当我们有个函数为 $y=wx+b$ 并且知道本函数穿过的两个点时我们可以轻易的算出函数中的常数$w$和$b$。\n假设有两点： $$ x_1=3,y_1=7 \\\nx_2=4,y_2=6 \\\n$$\n则其解为： $$ 7=3w+b \\\n6=4w+b \\\nw=-1,b=10 $$\n其曲线为：\nimport matplotlib.pyplot as plt plt.plot([3,4],[7,6]) plt.show() # show figure  1.2 观测误差 但是当我们的观测点存在误差时，公式变为了 $y=wx+b+\\epsilon,\\epsilon\\in\\mathcal{N}(\\mu,\\sigma^2)$. 此时我们无法用过之前的解法解出$w$和$b$的值。代码中采用random.random()-0.5模拟$\\epsilon$，我们会发现无论取哪两点去计算$w$和$b$都会导致函数存在巨大的偏离。我们只能通过回归分析去计算最佳的$w$和$b$。\nimport matplotlib.pyplot as plt import random x=range(0, 10) plt.plot(x,[-1*i+10+random.random()-0.5 for i in x], 'o') plt.plot(x,[-1*i+10 for i in x]) plt.show() # show figure  1.3 损失函数（loss） 此时我们引入了损失函数来计算$w$和$b$的好坏，在此例中采用均方误差(MSE)来评判： $$ \\mathscr{L}=\\frac{\\sum_{i=1}^{n}(wx_i+b-y_i)^2}n $$\n我们接下来的工作就是找到使$\\mathscr{L}$最小的$w$和$b$。\n1.4 梯度下降及优化函数 我们通过寻找$\\mathscr{L}$最小值来确定最佳的$w$和$b$，此时可通过求极值的方式来寻找损失函数的极小值。损失函数为三元方程，其偏导数即为梯度，我们用学习率(lr)来缩放梯度，通过不断的减去梯度来计算$w$和$b$，将其优化到最佳。 $$ w'=w-\\eta\\frac{\\partial \\mathscr{L}}{\\partial w} \\\nb'=b-\\eta\\frac{\\partial \\mathscr{L}}{\\partial b} \\\n\\eta\\text{为学习率 lr} $$\n解开偏导数以备后用： $$ \\begin{align} \\frac{\\partial \\mathscr{L}}{\\partial w} \u0026amp; = \\frac{\\partial \\frac{\\sum_{i=1}^{n}(wx_i+b-y_i)^2}n}{\\partial w} \\\n\u0026amp; = \\frac{2}{n}\\sum_{i=1}^{n} (wx_i+b-y_i)\\frac{\\partial (wx_i+b-y_i)}{\\partial w} \\\n\u0026amp; = \\frac{2}{n}\\sum_{i=1}^{n} (wx_i+b-y_i)x_i \\end{align} $$ $$ \\begin{align} \\frac{\\partial \\mathscr{L}}{\\partial b} \u0026amp; = \\frac{\\partial \\frac{\\sum_{i=1}^{n}(bx_i+b-y_i)^2}n}{\\partial b} \\\n\u0026amp; = \\frac{2}{n}\\sum_{i=1}^{n} (bx_i+b-y_i)\\frac{\\partial (bx_i+b-y_i)}{\\partial b} \\\n\u0026amp; = \\frac{2}{n}\\sum_{i=1}^{n} (bx_i+b-y_i) \\end{align} $$\n","date":1575165544,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1575165544,"objectID":"61ae28a7d2ab51bc0cef4328f71f647d","permalink":"/post/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%8F%8A%E5%AE%9E%E7%8E%B0/","publishdate":"2019-12-01T09:59:04+08:00","relpermalink":"/post/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%8F%8A%E5%AE%9E%E7%8E%B0/","section":"post","summary":"线性回归及实现 [TOC] 一年多前，《修真聊天群》更新看完了，在书荒引发的无聊情绪推动下学习了 Keras，用 LSTM 生成了大段无法看的《伪*修真聊天群》，没","tags":["回归"],"title":"线性回归及实现","type":"post"},{"authors":null,"categories":["技术"],"content":"我这么大个io_service去哪里了 [TOC]\n最近稍微闲了下来，开始debug Boost.Asio 析构时崩溃的问题。在目前代码中，使用到了deadline_timer作定时器。\n由于早期仅用简单的定时器，也就没多了解io_service的用法，简单地在每个短周期业务实例中各开了一组thread和io_service来挂deadline_timer。后来出现了一个问题，运行时发现在析构业务实例时delete io_service偶尔会崩溃（具体定位过程就不在这边展开了），就去看了源代码和reference。\n想着这么大的库api应该不会有太大的变化，点开boost最新版（1.71）reference，咦 O__O 我这么大个io_service去哪里了？\nLegend 1:Boost 1.71 Asio Reference 接下来从1.71版本往回翻，在1.66更新信息里发现一句话：  Implemented interface changes to reflect the Networking TS ( N4656).\n See the list of new interfaces and, where applicable, the corresponding old interfaces that have been superseded. The service template parameters, and the corresponding classes, are disabled by default. For example, instead of basic_socket we now have simply basic_socket. The old interface can be enabled by defining the BOOST_ASIO_ENABLE_OLD_SERVICES macro.   为了迎合C++ Networking TS的标准将接口改了，但是旧的接口依然还在支持。但一些service模板和相应的类默认不支持老版本，不过可以打开BOOST_ASIO_ENABLE_OLD_SERVICES宏来支持老版本service。\n以下仅列了一些我感兴趣的修改，完整版可以看上文的list链接。\n   New interface Old interface Notes      io_context  io_service The name io_service is retained as a typedef.    dispatch  io_service::dispatch The dispatch free function can be used to submit functions to any Executor or ExecutionContext.    post  io_service::post The dispatch free function can be used to submit functions to any Executor or ExecutionContext.    defer  io_service::post when the asio_handler_is_continuation hook returns true The defer free function can be used to submit functions to any Executor or ExecutionContext.    io_context::poll  io_service::poll overload that takes error_code\u0026amp; The error_code overload is not required.    io_context::poll_one  io_service::poll_one overload that takes error_code\u0026amp; The error_code overload is not required.    io_context::run  io_service::run overload that takes error_code\u0026amp; The error_code overload is not required.    io_context::run_one  io_service::run_one overload that takes error_code\u0026amp; The error_code overload is not required.    io_context::run_for, io_context::run_until, io_context::run_one_for, and io_context::run_one_until  These functions add the ability to run an io_context for a limited time.    io_context::restart  io_service::reset     execution_context, execution_context::service, and execution_context::id  io_service, io_service::service, and io_service::id The service-related functionality has been moved to the execution_context base class. This may also be used as a base for creating custom execution contexts.    make_service  add_service     strand  io_service::strand This template works with any valid executor, and is itself a valid executor.    executor_work_guard and make_work_guard  io_service::work Work tracking is now covered by the Executor requirements. These templates work with any valid executor.    Legend 2:Boost 1.71 Asio Interface Change List 在新接口表中我们可以看到`io_service`已经换成了`io_context`，且在1.66的[io_service](https://www.boost.org/doc/libs/1_66_0/doc/html/boost_asio/reference/io_service.html) reference中可以发现最上面就写了 ","date":1572400248,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1572400248,"objectID":"9310fe44067db2e29d1bc26ced1168bd","permalink":"/post/%E6%88%91%E8%BF%99%E4%B9%88%E5%A4%A7%E4%B8%AAio_service%E5%8E%BB%E5%93%AA%E9%87%8C%E4%BA%86/","publishdate":"2019-10-30T09:50:48+08:00","relpermalink":"/post/%E6%88%91%E8%BF%99%E4%B9%88%E5%A4%A7%E4%B8%AAio_service%E5%8E%BB%E5%93%AA%E9%87%8C%E4%BA%86/","section":"post","summary":"我这么大个io_service去哪里了 [TOC] 最近稍微闲了下来，开始debug Boost.Asio 析构时崩溃的问题。在目前代码中，使用到了deadline_time","tags":["C++"],"title":"我这么大个io_service去哪里了","type":"post"},{"authors":null,"categories":["coding"],"content":"boost.asio核心浅析 ","date":1572335450,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1572335450,"objectID":"d7d848b8bf47a68196fcc391a294dce9","permalink":"/post/boost.asio%E6%A0%B8%E5%BF%83%E6%B5%85%E6%9E%90/","publishdate":"2019-10-29T15:50:50+08:00","relpermalink":"/post/boost.asio%E6%A0%B8%E5%BF%83%E6%B5%85%E6%9E%90/","section":"post","summary":"boost.asio核心浅析","tags":["boost","c++"],"title":"boost.asio核心浅析","type":"post"},{"authors":null,"categories":["coding"],"content":"C++公共模块回调函数实现方式 在代码实现时，常常会遇到模块间函数调用的问题。对于一个公共模块，会有明确的public方法来作为接口，但是当需要发送消息（此处仅讨论回调函数）到外部业务模块的时候就很难去定义回调函数的类型。通常在命令式编程中会采用函数指针的方法，但在OO中调用者是一个类的话很难将类成员函数发给基础模块做回调函数。\n1. 传统函数指针回调 ","date":1567654807,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1567654807,"objectID":"ba62a6afd924612458b1b2fc9b1a3c2e","permalink":"/post/c++%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/","publishdate":"2019-09-05T11:40:07+08:00","relpermalink":"/post/c++%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/","section":"post","summary":"C++公共模块回调函数实现方式 在代码实现时，常常会遇到模块间函数调用的问题。对于一个公共模块，会有明确的public方法来作为接口，但是当需","tags":["c++","coding"],"title":"C++公共模块回调函数实现方式","type":"post"},{"authors":null,"categories":null,"content":"Git分支使用方法 分支概要 分支使用tip:\n 设三个分支, master/release/develop master和release 设置为只能管理员merge 可以把develop设置为默认分支 未来在网页端merge选上 Squash commits when merge request is accepted. merge到master分支上需要打上tag feature分支大家可自由创建~ 命名为 feature/xxx feature分支合并至develop时, 和以上一样选择. 最后次合入时同时选上 Delete source branch when merge request is accepted. 以删除feature分支  后续我会写一篇文档.\n参考文献  A successful Git branching model Git仓库分支(Branch)和标签(Tag)\n","date":1562321247,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1562321247,"objectID":"c0fc373e76997e3daa8f620dbc995683","permalink":"/post/git%E5%88%86%E6%94%AF%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","publishdate":"2019-07-05T10:07:27Z","relpermalink":"/post/git%E5%88%86%E6%94%AF%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","section":"post","summary":"Git分支使用方法 分支概要 分支使用tip: 设三个分支, master/release/develop master和release 设置为只能管理员merge 可以把develop设置为默认","tags":null,"title":"Git分支使用方法","type":"post"},{"authors":null,"categories":null,"content":"Windows 下 C++ 编程环境指导   Windows 下 C++ 编程环境指导   背景介绍  操作系统建议  Windows Subsystem for Linux  命令行环境参考   Windows   PowerShell 插件  Windows下命令行软件安装    Linux  命令行软件    C++ 代码规范   Google C++ Style Guide  Lint    编辑器指引   Clion配置   注册码  WSL连接  Google C++ Style Guide 配置    VSCode配置   强烈建议安装插件  建议安装插件:  可用Sync配置        背景介绍 最近安装了 Windows 系统，从来没有在 Windows 下面做过 Unix C++ 开发的我略有些懵逼（为什么在 windows 下开发是 Unix？因为我主要还是用 macOS 和 linux）。在经过一段时间的适应后，总结下Windows下开发的经验，供后续查看。\n操作系统建议 建议采用 Windows 10 作为工作的操作系统, 并安装WSL作为编译环境(详见下文).\n服务器使用 Ubuntu / CentOS / Manjaro.\n我个人服务器使用 Manjaro，这是一个滚动式更新的系统，是在Arch Linux基础上修改的更加易用的发行版。软件众多，同时社区维护的 aur 也支持直接从github上获取源代码编译安装。\nWindows Subsystem for Linux  Windows Subsystem for Linux（简称WSL）是一个为在Windows 10上能够原生运行Linux二进制可执行文件（ELF格式）的兼容层。它是由微软与Canonical公司合作开发，目标是使纯正的 Ubuntu 映像能下载和解压到用户的本地计算机，并且映像内的工具和实用工具能在此子系统上原生运行。\n安装指引请查看Microsoft官网: Linux 安装指南适用于 Windows 10 的 Windows 子系统\n后续 WSL2 发行后，本段再做修改。考虑到 WSL 和 WSL2 是不冲突的两种功能，届时再看使用哪一种。\n命令行环境参考 Windows 主要采用PowerShell, 详情参考 PowerShell官网.\nPowerShell 插件 PowerShell插件主要位于 PowerShell Gallery, 可安装oh-my-posh, posh-git等插件\nWindows下命令行软件安装 Windows下包管理器主要采用 Choco, 可像Linux下包管理器一样使用.\nLinux Linux 下命令行建议采用 zsh, 并加装 Oh-my-zsh. （WSL自然也包括在其中）\n以下为安利贴: 为什么说 zsh 是 shell 中的极品？\n命令行软件 Windows下命令行软件建议采用 FluentTerminal, 使用Choco安装 choco install fluent-terminal. 在设置中可选择WSL/PowerShell/CMD 作为默认命令行, 建议采用WSL.\nC++ 代码规范 Google C++ Style Guide C++代码规范目前采用 Google C++ Style Guide 也可参考 此中文版教程.\n后续会有微调, 将会详细写出.\nLint Lint采用 Clang-tidy做静态分析, 目前项目根目录有clang-tidy.py 文件来做批量Lint. 可采用命令行 ./clang-tidy.py -checks \u0026quot;google-*\u0026quot; -fix -p ./build ./src/* 做检查.\n编辑器指引 编辑器采用 Clion作为C++开发编辑器, Visual Studio Code 作为辅助编辑器使用.\nClion配置 注册码 Clion注册码可以去淘宝购买，2018-02版本后授权服务器已失效。\nWSL连接 请参考Clion官方文档: How to use wsl development environment in clion\nGoogle C++ Style Guide 配置 请参考Clion官方文档: Code Style. C/C++ #Set From\n在Set From 中选择 Google.\nVSCode配置 强烈建议安装插件  配置同步  settings sync   Git相关  gitblame githistory gitlens   C++相关  cmake cmake-tools cpptools include-autocomplete   Markdown及UML相关  markdown-all-in-one markdown-preview-enhanced plantuml vscode-markdownlint   方便编辑  beautify indent-rainbow output-colorizer path-intellisense rainbow-csv    建议安装插件: 可能有点多\u0026hellip;可自行筛选, 覆盖了一些常用语言\n auto-close-tag\rauto-rename-tag\rbackground\rbeautify\rbetter-toml\rbracket-pair-colorizer\rchange-case\rcmake\rcmake-tools\rcode-runner\rcode-settings-sync\rcode-spell-checker\rcopilot-vscode\rcpptools\rgc-excelviewer\rgitblame\rgithistory\rgitlens\rGo\rinclude-autocomplete\rindent-rainbow\riris\rJavaScriptSnippets\rmarkdown-all-in-one\rmarkdown-pdf\rmarkdown-preview-enhanced\rmssql\rnbpreviewer\rnodejs-docs\routput-colorizer\rpath-intellisense\rplantuml\rpowershell\rpyqt-integration\rpython\rquicktype\rrainbow-csv\rreact-native-react-redux\rrest-client\rtheme-dracula\rtslint\rvs-color-picker\rvscode-babel-coloring\rvscode-clang\rvscode-database\rvscode-eslint\rvscode-filesize\rvscode-hexdump\rvscode-hexo\rvscode-import-cost\rvscode-insertdatestring\rvscode-language-babel\rvscode-language-pack-zh-hans\rvscode-leetcode\rvscode-markdownlint\rvscode-mysql\rvscode-power-mode\rvscode-qt-for-python\rvscode-styled-components\rvscode-svgviewer\rvscode-text-pastry\rvscode-yaml\rwebpack\r 可用Sync配置 首先安装settings sync插件, 选择同步公开gist: 7b4026c4de4f3170fb1770945dbdf52e\n","date":1558367529,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1558367529,"objectID":"39f10a5c4dbc8ef608fc0d5b2167e6a1","permalink":"/post/windows%E4%B8%8B-c++-%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83/","publishdate":"2019-05-20T15:52:09Z","relpermalink":"/post/windows%E4%B8%8B-c++-%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83/","section":"post","summary":"Windows 下 C++ 编程环境指导 Windows 下 C++ 编程环境指导 背景介绍 操作系统建议 Windows Subsystem for Linux 命令行环境参考 Windows PowerShell 插件 Windows下命令行软件安装 Linux 命令行软件 C++ 代码规范 Google","tags":null,"title":"Windows 下 C++ 编程环境","type":"post"},{"authors":null,"categories":null,"content":"C++ 开发环境指引   C++ 开发环境指引   操作系统建议  Windows Subsystem for Linux  命令行环境参考   Windows   PowerShell 插件:  Windows下命令行软件安装:    Linux  命令行软件    C++ 代码规范   Google C++ Style Guide  Lint    编辑器指引   Clion配置   注册码  WSL连接  Google C++ Style Guide    VSCode配置   强烈建议安装插件  建议安装插件:  可用Sync配置      日报  Git指引    操作系统建议 建议采用 Windows 10 作为工作的操作系统, 并安装WSL作为编译环境(详见下文).\n服务器使用 Ubuntu 或 CentOS. 当前为同一WSL环境, 使用Ubuntu作为上线系统.\nWindows Subsystem for Linux  Windows Subsystem for Linux（简称WSL）是一个为在Windows 10上能够原生运行Linux二进制可执行文件（ELF格式）的兼容层。它是由微软与Canonical公司合作开发，目标是使纯正的 Ubuntu 映像能下载和解压到用户的本地计算机，并且映像内的工具和实用工具能在此子系统上原生运行。\n安装指引请查看Microsoft官网: Linux 安装指南适用于 Windows 10 的 Windows 子系统\n命令行环境参考 Windows 主要采用PowerShell, 详情参考 PowerShell官网.\nPowerShell 插件: PowerShell插件主要位于 PowerShell Gallery, 可安装oh-my-posh, posh-git等插件\nWindows下命令行软件安装: Windows下包管理器主要采用 Choco, 可像Linux下包管理器一样使用.\nLinux Linux下命令行建议采用zsh, 并加装 Oh-my-zsh.\n以下为安利贴: 为什么说 zsh 是 shell 中的极品？\n命令行软件 Windows下命令行软件建议采用 FluentTerminal, 使用Choco安装 choco install fluent-terminal. 在设置中可选择WSL/PowerShell/CMD 作为默认命令行, 建议采用WSL.\nC++ 代码规范 Google C++ Style Guide C++代码规范目前采用 Google C++ Style Guide 也可参考 此中文版教程.\n后续会有微调, 将会详细写出.\nLint Lint采用 Clang-tidy做静态分析, 目前项目根目录有clang-tidy.py 文件来做批量Lint. 可采用命令行 ./clang-tidy.py -checks \u0026quot;google-*\u0026quot; -fix -p ./build ./src/* 做检查.\n编辑器指引 编辑器采用 Clion作为C++开发编辑器, Visual Studio Code 作为辅助编辑器使用.\nClion配置 注册码  Clion注册码\nWSL连接 请参考Clion官方文档: How to use wsl development environment in clion\nGoogle C++ Style Guide 请参考Clion官方文档: Code Style. C/C++ #Set From\n在Set From 中选择 Google.\nVSCode配置 强烈建议安装插件  配置同步  settings sync   Git相关  gitblame v2.7.0 githistory v0.4.6 gitlens v9.7.4   C++相关  cmake v0.0.17 cmake-tools v1.1.3 cpptools v0.23.1 include-autocomplete v0.0.4   Markdown及UML相关  markdown-all-in-one v2.3.1 markdown-preview-enhanced v0.3.13 plantuml v2.11.0 vscode-markdownlint v0.26.0   方便编辑  beautify v1.5.0 indent-rainbow v7.4.0 output-colorizer v0.1.2 path-intellisense v1.4.2 rainbow-csv v1.0.0    建议安装插件: 可能有点多\u0026hellip;可自行筛选, 覆盖了一些常用语言\n auto-close-tag v0.5.6\rauto-rename-tag v0.0.15\rbackground v1.1.19\rbeautify v1.5.0\rbetter-toml v0.3.2\rbracket-pair-colorizer v1.0.61\rchange-case v1.0.0\rcmake v0.0.17\rcmake-tools v1.1.3\rcode-runner v0.9.9\rcode-settings-sync v3.2.9\rcode-spell-checker v1.7.10\rcopilot-vscode v1.3.0\rcpptools v0.23.1\rgc-excelviewer v2.1.32\rgitblame v2.7.0\rgithistory v0.4.6\rgitlens v9.7.4\rGo v0.10.2\rinclude-autocomplete v0.0.4\rindent-rainbow v7.4.0\riris v0.0.4\rJavaScriptSnippets v1.7.2\rmarkdown-all-in-one v2.3.1\rmarkdown-pdf v1.2.0\rmarkdown-preview-enhanced v0.3.13\rmssql v1.6.0\rnbpreviewer v1.2.2\rnodejs-docs v0.2.2\routput-colorizer v0.1.2\rpath-intellisense v1.4.2\rplantuml v2.11.0\rpowershell v1.12.1\rpyqt-integration v0.2.0\rpython v2019.4.12954\rquicktype v12.0.46\rrainbow-csv v1.0.0\rreact-native-react-redux v2.0.3\rrest-client v0.21.3\rtheme-dracula v2.18.0\rtslint v1.0.43\rvs-color-picker v1.0.0\rvscode-babel-coloring v0.0.4\rvscode-clang v0.2.3\rvscode-database v2.1.5\rvscode-eslint v1.9.0\rvscode-filesize v2.1.2\rvscode-hexdump v1.7.2\rvscode-hexo v1.0.1\rvscode-import-cost v2.12.0\rvscode-insertdatestring v2.2.4\rvscode-language-babel v0.0.22\rvscode-language-pack-zh-hans v1.33.2\rvscode-leetcode v0.14.3\rvscode-markdownlint v0.26.0\rvscode-mysql v0.4.0\rvscode-power-mode v2.2.0\rvscode-qt-for-python v0.3.0\rvscode-styled-components v0.0.26\rvscode-svgviewer v2.0.0\rvscode-text-pastry v1.2.0\rvscode-yaml v0.4.0\rwebpack v2.1.3\r 可用Sync配置 首先安装settings sync插件, 选择同步公开gist: 7b4026c4de4f3170fb1770945dbdf52e\n日报  研发部日报Git\nGit指引  Git的奇技淫巧\n","date":1558347054,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1558347054,"objectID":"e722db0ec411b91624a77afceb00dfbd","permalink":"/post/c++%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%8C%87%E5%BC%95/","publishdate":"2019-05-20T10:10:54Z","relpermalink":"/post/c++%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%8C%87%E5%BC%95/","section":"post","summary":"C++ 开发环境指引 C++ 开发环境指引 操作系统建议 Windows Subsystem for Linux 命令行环境参考 Windows PowerShell 插件: Windows下命令行软件安装: Linux 命令行软件 C++ 代码规范 Google C++ Style Guide Lint 编辑","tags":null,"title":"C++ 开发环境指引","type":"post"},{"authors":null,"categories":null,"content":"vision详细设计   vision详细设计   1 背景介绍    1 背景介绍 ","date":1547297543,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1547297543,"objectID":"60817e74b1c51373bbf297da7002a591","permalink":"/post/vision%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/","publishdate":"2019-01-12T12:52:23Z","relpermalink":"/post/vision%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/","section":"post","summary":"vision详细设计 vision详细设计 1 背景介绍 1 背景介绍","tags":null,"title":"vision详细设计","type":"post"},{"authors":null,"categories":null,"content":"博客系统的需求在哪里 半年前，有了更多对前端的思考便打算将自研博客系统落地。这个想法由来已久，从大学时期的 wordpress、dokuwiki到\u0008毕业后搭建的 hexo 静态博客，折腾了系统、捣鼓了插件，最终写的文章寥寥，后来也兴致缺缺。渐渐就期望有一个亲手建立的博客系统，\u0008删减复杂的功能，保留最精要的功能即可。\n差不多花了一个月时间\u0008写出了博客主要的功能，采用了 Twitter 的页面风格，前端架构主要使用 react + mobx + antd，后端使用 flask。\u0008Feature 包括了人脸识别登陆、markdown在线编辑、moment 和博客差异化显示、支持 hashtag 等等。\n闲来也写了点东西，功能确实精简也舒适，无需手动登录，允许网页使用摄像头就能开始在任何地方写作了。但慢慢发现使用起来又回到了最初的问题，似乎又懒得写作了。画图需要先画，再截图，然后上传到七牛，最后把地址丢在\u0008文章中，图片一多（人）就崩溃了，即使用了一些手段图片自动上传七牛，流程依然复杂。\u0008即使后面做下去我做到最好也就是现有博客系统的层次，对我来说依然是鸡肋的。\n最近想了想，无论是 wp、hexo 还是自研博客说到底是工具不称手了，没有系统化的思考过写作到底是什么，用发布工具来当做写作平台，自然有些南橘北枳的感觉。遵循接口设计的一系列原则，我们应该将模块\u0008功能做到尽可能单一、对外暴露尽可能小，就这两点去思考之前的写作流程，便会发现我做错了，博客网站功能依然太多了，需要再进行功能的划分。\n我们首先将写作一整个流程进行拆分：\n 灵感 腹稿 \u0008大纲(暂时我随性写) 写作 发布  之前的错误在于混淆了写作与发布流程，糅杂在了一起。虽然在线的富文本编辑器非常好用，方便做排版之类的工作，但是终究是功能不完善的，而且不能做到本地软件这样的方便。\n考虑了半天，还是写作和发布分离吧，其中最复杂的地方可能是所见即所得，因此要求网页后台 markdown 渲染和编辑器 markdown 采用同一套渲染方案。这样再编辑器上写的东西就能保证和网页上显示的一样了。\n这部分找了些资料，例如 marked、highlight、simplemde等前端 md 渲染或是富文本编辑器，似乎效果都会有出入。最终准备从 vscode 入手，发现 markdown preview exhance 的作者有在 github 开源其插件，从插件的代码中不难找到他使用的 markdown 渲染方式。\n最终在其另一个开源项目『 mume』中找到了解决方案，其调用非常简单，在 vscode 中的插件配置项几乎源于这一项目的配置。在做新的博客页面时直接用mume渲染即可~ 当然这样就相当于是另外做一套静态网页了。（这个想法倒是可以和原作者交流呢~ hhh）\n新博客系统其实并不类似静态网页，依然会有前后端交互，只是将文章部分的渲染交给了后端的mume，前端的 marked 渲染依旧会继续使用，用于渲染出摘要。\n这样的新设计，抛弃了\u0008原有的一堆功能，在新方案中，将会有四个成员来完成一整套博客系统：\n 撰写工具：vscode+mpe 发布工具：nodejs+mume 将和mpe 使用同一份配置，保证所见即所得 后端：仅用于读取数据库 前端：依然采用之前的展示方式，删去渲染部分  这样的方案，写作流程就会变得更简单，对于 markdown 来说比较麻烦的图床也可以通过 mpe 中的图片管理来解决。\n","date":1539346997,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1539346997,"objectID":"7841dfdebde1f662e24a466bf286fd41","permalink":"/post/%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%9C%80%E6%B1%82%E5%9C%A8%E5%93%AA%E9%87%8C/","publishdate":"2018-10-12T12:23:17Z","relpermalink":"/post/%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%9C%80%E6%B1%82%E5%9C%A8%E5%93%AA%E9%87%8C/","section":"post","summary":"博客系统的需求在哪里 半年前，有了更多对前端的思考便打算将自研博客系统落地。这个想法由来已久，从大学时期的 wordpress、dokuwiki","tags":null,"title":"博客系统的需求在哪里","type":"post"},{"authors":null,"categories":["coding"],"content":"LYAH字典查询函数理解指南 for what 最近在看Haskell，并且极度想要给好基友安利这一个语言。So，今天看 《Learn You a Haskell for Great Good》恰巧基友被我安利烦了，问我haskell有什么好的，我刚看到§7.4 Data.Map这章，就发了看到的第一个函数给他，不过感觉他会看不懂，就想写个讲解给他，写长了之后就想成文了。\n那个函数 这是一个从字典中找值的函数\n findKey :: (Eq k) =\u0026gt; k -\u0026gt; [(k,v)] -\u0026gt; v\nfindKey key xs = snd . head . filter (\\(k,v) -\u0026gt; key == k) $ xs\n 举个栗子 这个例子同样是从LYAH中搞出来的：\n phoneBook = [(\u0026ldquo;betty\u0026rdquo;,\u0026ldquo;555-2938\u0026rdquo;) , (\u0026ldquo;bonnie\u0026rdquo;,\u0026ldquo;452-2928\u0026rdquo;) , (\u0026ldquo;patsy\u0026rdquo;,\u0026ldquo;493-2928\u0026rdquo;) ,\n(\u0026ldquo;lucille\u0026rdquo;,\u0026ldquo;205-2928\u0026rdquo;) ,\n(\u0026ldquo;wendy\u0026rdquo;,\u0026ldquo;939-8282\u0026rdquo;) ,\n(\u0026ldquo;penny\u0026rdquo;,\u0026ldquo;853-2492\u0026rdquo;) ]\n 函数申明  findKey :: (Eq k) =\u0026gt; k -\u0026gt; [(k,v)] -\u0026gt; v\n 在函数中，首先第一行是函数申明，他和其他语言一样表明了输入输出。\n在haskell中函数仅支持一个返回值，支持多个入参。在上面的申明中 findKey 是函数名，以 \u0026ldquo;::\u0026ldquo;来标明函数，后面一共有四个东西，\n (Eq k) =\u0026gt; k -\u0026gt; [(k,v)] -\u0026gt; v\n 首先可以仅理解后三个：\n k -\u0026gt; [(k,v)] -\u0026gt; v\n 这是函数参数和返回值，这个函数中一共有两个参数和一个返回值，函数申明中的最后一个箭头\u0026rdquo;-\u0026gt;\u0026ldquo;是一定指向返回值的，当然\u0026rdquo;k v\u0026ldquo;这两个字母一定会让人觉得很疑惑，在haskell中函数声明中的字母其实只代表一个变量类型哦 sorry，haskell中没有变量，他只有常量，所有都是静态参数，所以这个字母代表了一种模糊的参数类型，这仅表示上面两个k需要是同样的类型，而两个v也需要是同样的类型，随便用abcd也可以。所以：\n \u0026rdquo;k\u0026rdquo; \u0026ldquo;[(k,v)]\u0026rdquo; 是两个入参，第一个参数是k类型的参数，第二个参数是一个list，list中是一个有两个类型为k v为成员的tuple\n\u0026rdquo;v\u0026rdquo; 是函数的返回值，它的类型需要和入参list中tuple第二个元素一样。\n 然后我们来说一说\u0026rdquo;(Eq k) =\u0026gt;\u0026quot;, \u0026ldquo;=\u0026gt;\u0026ldquo;是对后面参数的约束条件，\u0026quot;(Eq k)\u0026ldquo;说明后面的 \u0026ldquo;k\u0026rdquo; 类型的参数必须是一个Eq的派生类型，这种类型是可以比较的，比如int，char。\n在事例中我们可以按照\n findKey \u0026ldquo;betty\u0026rdquo; phoneBook\n 的方式进行调用，其中phoneBook可扩展成的[(\u0026ldquo;betty\u0026rdquo;,\u0026ldquo;555-2938\u0026rdquo;)\u0026hellip;]，看起来形式就差不多了。\n函数实体 函数调用  findKey key xs = snd . head . filter (\\(k,v) -\u0026gt; key == k) $ xs\n 这是函数体，在等号左边的是函数调用的方式，在这个函数中，调用方式是：\n findKey key xs\nexample:findKey \u0026ldquo;betty\u0026rdquo; phoneBook\n 当然也可以是中序，这个就另讲了。这个函数调用方式也是一种模式匹配，这边的\u0026rdquo;key\u0026quot;、\u0026quot;xs\u0026ldquo;匹配了函数的两个入参\u0026rdquo;k\u0026quot;、\u0026quot;[(k,v)]\u0026rdquo;\nfilter 接下来对这两个入参进行操作(先忽略\u0026rdquo;$\u0026ldquo;符号)：\n filter (\\(k,v) -\u0026gt; key == k) xs\n 首先是filter，这个是对一个list的过滤器，是\u0026rdquo;filter f list\u0026rdquo; 这样的模式，对list的每一个元素使用函数f进行匹配。在此例中\n (\\(k,v) -\u0026gt; key == k)\n 就是filter中的 f ，haskell中使用 \\做lambda，lambda就是一个隐式函数。\n在lambda中\u0026rdquo;-\u0026gt;\u0026ldquo;是用来区分参数和lambda函数本体的，在\u0026rdquo;-\u0026gt;\u0026ldquo;左边是函数参数，可做模式匹配。在此lambda函数中，用\u0026rdquo;(k,v)\u0026ldquo;来匹配list成员tuple的成员。第一个\u0026rdquo;(k,v)\u0026ldquo;就是：\n (\u0026ldquo;betty\u0026rdquo;,\u0026ldquo;555-2938\u0026rdquo;)\n 此lambda用来匹配 xs 这个list取出来的每一个元组，并且判断此元组中的键值 k 是否能匹配入参的 key。并且filter会将符合条件的元素==重新组合==成一个新的list，在此例中，filter结果就是\n [(\u0026ldquo;betty\u0026rdquo;,\u0026ldquo;555-2938\u0026rdquo;)]\n 后面键值不为***\u0026ldquo;betty\u0026rdquo;***的元组就会被舍弃，这是仅有一个元素的list。\nsnd head 接下来这个是head，这个函数用来取list的头部，取出来就是第一个元素，例如\n ***head [3,2,5,3,6,3,4,3,7]***的结果就是3\n 在此例中结果大致是：\n (\u0026ldquo;betty\u0026rdquo;,\u0026ldquo;555-2938\u0026rdquo;)\n 是的，你会发现，这仅仅是去掉了中括号，这代表着这不再是一个list了。\n接下来snd用来取tuple中的第二个元素，就是字典中的value，也就是\n \u0026ldquo;555-2938\u0026rdquo;\n 就能得出函数返回值了。这边需要注意的是，snd的参数只能是二元tuple。\n函数组合 snd . head . filter 这个是函数组合，相当于一下子调用了三个函数。这个可以用数学公式来表示：\n (f.g)(x) = f(g(x))\n 在此处\n snd.head.filter f $ list = snd(head(filter f list)))\n 在haskell中，函数组合是一个让代码简洁明了的手段，但是他也有它的局限性，就是说他的参数只能唯一，函数组合仅能包含一个参数。但是此处柯里化使得组合函数使用多参成为可能。\n柯里化（Currying） 柯里化是现代化语言中包含的一个非常有趣的特性之一，在js、swift中也支持柯里化（非常遗憾swift仅在Language Reference中提到了一点）。\nCurrying是指函数可以不完全调用，他可以将多参函数转化为单参函数来求解。例如\u0026rdquo;+\u0026ldquo;函数（对，在haskell中\u0026rdquo;+\u0026ldquo;也是一个函数）\n 5+4 =======\u0026gt; 9\n 其可以转化为：\n let plusFive = (+5)\n 这样一来我们就多了一个新的函数叫做plusFive，我们来调用它：\n plusFive 4 =======\u0026gt; 9\nplusFive 167 =======\u0026gt; 172\n ok，Currying就是这样一个好玩的特性，我自己认为，这个和惰性有关，因为Curried Function切切实实要在有完整入参时才会调用。\n对于本例来说，我们将\n filter (\\(k,v) -\u0026gt; key == k) xs Currying成 ***(filter (\\(k,v) -\u0026gt; key == k)) xs***\n 在组合函数中其实是组合成了\n ***(snd . head . filter (\\(k,v) -\u0026gt; key == k)) xs***\n 在原函数中，少了\u0026rdquo;()\u0026quot;,多了\u0026rdquo;$\u0026quot;:\n snd . head . filter (\\(k,v) -\u0026gt; key == k) $ xs\n 这边用到了的\u0026rdquo;$\u0026quot;,如果缺少\u0026rdquo;$\u0026rdquo;\n snd . head . filter (\\(k,v) -\u0026gt; key == k) xs 会被理解成\nsnd . head . (filter (\\(k,v) -\u0026gt; key == k) xs)\n 而这绝对是会被编译器理解不能的句子，会报错，\u0026quot;$\u0026ldquo;改变了filter函数的匹配方式，在haskell中\u0026rdquo;$\u0026ldquo;是拥有最低优先级的函数调用符，相当于一个函数，所以会变成\n snd . head . filter (\\(k,v) -\u0026gt; key == k) ($ xs)\n 函数组合的优先级大于$ xs的优先级，就会前面线组合起来。\u0026quot;$\u0026ldquo;是一个非常节约括号的函数调用符.\n函数结论  findKey \u0026ldquo;betty\u0026rdquo; phoneBook\n***\u0026ldquo;555-2938\u0026rdquo;***\n***findKey \u0026ldquo;patsy\u0026rdquo; phoneBook***\n***\u0026ldquo;493-2928\u0026rdquo;***\n 就此结束吧，心血来潮谢谢，先打上个标签1，说不定还有2，3，4\u0026hellip;呢，也或许会太监了呢。\n","date":1446909755,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1446909755,"objectID":"763f948e0af7b0fd505d2cc19b9c2286","permalink":"/post/about-haskell-1/","publishdate":"2015-11-07T23:22:35+08:00","relpermalink":"/post/about-haskell-1/","section":"post","summary":"LYAH字典查询函数理解指南 for what 最近在看Haskell，并且极度想要给好基友安利这一个语言。So，今天看 《Learn You a Haskell for Great Good》恰巧基友被我安利烦了，问我haskell有什么好的，我刚看到§7.4 Data.Map这章，就发了看到的第一个函数给他，不过感觉他会看不懂，就想写个讲解给他，写长了之后就想成文了。\n","tags":["haskell","currying","functional programming"],"title":"关于haskell随便写点什么1","type":"post"}]