[{"authors":["admin"],"categories":null,"content":"叮！这是一个非常混乱的站点，全是 XJB 乱写的文章（没错！很多都只写了一半！\n甚至连主题都还没设定好。哦！我太菜了！\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"zh","lastmod":-62135596800,"objectID":"38823022532afb073b52a7bca40a5f32","permalink":"https://blog.morningtzh.com/authors/morningtzh.html","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/morningtzh.html","section":"authors","summary":"叮！这是一个非常混乱的站点，全是 XJB 乱写的文章（没错！很多都只写了一半！ 甚至连主题都还没设定好。哦！我太菜了！","tags":null,"title":"","type":"authors"},{"authors":["Friend"],"categories":null,"content":"Never give up!\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"zh","lastmod":-62135596800,"objectID":"694bc8e345806718ca76dc5263e1d6eb","permalink":"https://blog.morningtzh.com/authors/tardis.html","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/tardis.html","section":"authors","summary":"Never give up!","tags":null,"title":"","type":"authors"},{"authors":["Friend"],"categories":null,"content":"书看的不多，脾气倒是很冲\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"zh","lastmod":-62135596800,"objectID":"b741ea563d670ad01b16c7523f4d2183","permalink":"https://blog.morningtzh.com/authors/ultraji.html","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/ultraji.html","section":"authors","summary":"书看的不多，脾气倒是很冲","tags":null,"title":"","type":"authors"},{"authors":["Friend"],"categories":null,"content":"一个瞎折腾活在楚门世界的小菜鸡\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"zh","lastmod":-62135596800,"objectID":"56e8354ab0b24b4f935adea7f6d6ed9f","permalink":"https://blog.morningtzh.com/authors/yunxia.html","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/yunxia.html","section":"authors","summary":"一个瞎折腾活在楚门世界的小菜鸡","tags":null,"title":"","type":"authors"},{"authors":null,"categories":["图形学"],"content":"图形学入门\u0026ndash;渲染管线 [TOC]\n目录  渲染管线纵览 继续回顾变换  相机变换 投影及物体变换   栅格化  抗锯齿 Z-Buffer   就这？只有颜色？   上次大致写了一下变换，那是本文的基础。本次将会对渲染管线做一个比较详细的笔记，大半个月没看图形学了，正好复习一下。\n 图形学入门\u0026ndash;入门 是对 GAMES101: 现代计算机图形学入门 课程的 Lecture 2~3 做了总结，本次将会对 Lecture 4~7 做一个总结。\n    课程名 课件链接 虎书第四版相应章节     Lecture 4 变换（模型、视图、投影）  课件 阅读材料：第 6 章（Transformation Matrices），第 6.2、6.4、6.5 节；第 7 章（Viewing）   Lecture 5 光栅化（三角形的离散化）  课件 阅读材料：第 3 章（Raster Images）, 第 3.1、3.2 节   Lecture 6 光栅化（深度测试与抗锯齿）  课件 阅读材料：第 8 章（The Graphics Pipeline）, 第 8.2.3 节；第 9 章（Signal Processing）   Lecture 7 着色（光照与基本着色模型）  课件 阅读材料：第 10 章（Surface Shading）, 第 10.1 节    渲染管线纵览 可以先看看Lecture 8中的渲染管线图。\n这边的步骤分为\n 点处理 三角处理 栅格化 片元处理 片元混合  接下来一步步将模型在图像中画出来\n继续回顾变换 虽然在 图形学入门\u0026ndash;入门 中已经讲过变换了，但是那仅是针对某个模型围绕原点的变换，但事实上大部分物体不会在原点，并且在场景中会有很多的模型。这一小节变换会回顾一下如何通过变换计算出摄像机所拍摄出的模型。\n相机变换 当我们在blender中创建一个工程，会像上图这样自动创建出盒子和摄像机（这边不关心那个光）。对于这样的一个模型很难去做采样，所以通常的做法是将所有需要被拍摄的模型重新放置在以摄像机为原点的坐标上。\n摄像机有三个属性：\n 位置（Position $\\vec{e}$）：这个很容易理解，并且在变换中也提到了位置的概念，即从原点到物体的向量； 朝向（Look-at $\\hat{g}$）：用过游戏引擎的人会对Look-at比较有感受，他是物体面向的方向，对摄像机来说就是摄像机拍摄的方向，需要注意的是这个向量仅代表方向，因此只要是单位向量即可； 上方向（Up direction $\\hat{t}$）：这也是一个单位向量，与look-at共同表示出摄像机完整的朝向信息，他与look-at正交；  通过这三个位置和朝向信息就能来重新计算模型的坐标，让其放在摄像机为原点的坐标上。在 GAMES101: 现代计算机图形学入门 课程中，将up设定为Y轴方向，look at -Z轴方向。（就当下图是对的，用过blender的同学千万不要揭穿我）\n变换矩阵 $M_{view}$ 的计算方式就是：\n 移动 $-\\vec{e}$ 到原点; 旋转 $\\hat{g}$ 到 -Z； 旋转 $\\hat{t}$ 到 Y； 旋转 $(\\hat{g}\\times\\hat{t})$ 到 X。  旋转比较难计算，但是由于旋转是可逆的，并且旋转是正定矩阵（ $R_{45} \\cdot R_{-45} = I$ 满足正定性，即 $A^TA=I$ , 回顾变换可发现$R_{45}$ 和 $R_{-45}$ 的关系满足转置 ），我们可以先计算以上2～4步的逆矩阵，即\n X 到 $(\\hat{g}\\times\\hat{t})$ Y 到 $\\hat{t}$ -Z 到 $\\hat{g}$  然后再求转置即可。这边懒得写了，直接给结论。\n$$ T_{view} = \\left[ \\begin{matrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; -x_{\\vec{e}}\\\\\n0 \u0026amp; 1 \u0026amp; 0 \u0026amp; -y_{\\vec{e}}\\\\\n0 \u0026amp; 0 \u0026amp; 1 \u0026amp; -z_{\\vec{e}}\\\\\n0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{matrix} \\right] $$ $$ R_{view} = \\left[ \\begin{matrix} x_{\\hat{g}\\times\\hat{t}} \u0026amp; y_{\\hat{g}\\times\\hat{t}} \u0026amp; z_{\\hat{g}\\times\\hat{t}} \u0026amp; 0\\\\\nx_{\\hat{t}} \u0026amp; y_{\\hat{t}} \u0026amp; z_{\\hat{t}} \u0026amp; 0\\\\\nx_{-\\hat{g}} \u0026amp; y_{-\\hat{g}} \u0026amp; z_{-\\hat{g}} \u0026amp; 0\\\\\n0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{matrix} \\right] $$ $$ M_{view} = R_{view} T_{view} $$\n通过相机的变换就能将模型转移到相机为原点的坐标上，再以此进行计算。\n投影及物体变换 在这边我们可以看到透视投影（左）与正交投影（右）在相机中显示的样子。\n从简单的正交投影开始说。正交投影从三维的角度看过去会有一个长方体盒：\n 近平面：摄像机能看到最近的地方，也就是最终生成投影的位置； 原平面：摄像机能看到的最远距离，这边我们假设他是有限度的； 上下左右四个平面：摄像机的视野范围； 宽高比：记得有个属性即可；  这里的的距离单位是长度单位，可能是千米 / 米 / 厘米，但屏幕上是像素点，我们需要进行转换，根据视野的大小一一映射到屏幕像素点上。这边做的处理就是将长方体盒转换成标准立方体，即$[-1,1]^3$ ，然后再根据画面像素扩展到相应大小后再做投影。\n这个知识点我在看视频时可能由于是1.5倍速度播放，并没有很好的理解它，上一段文字的理解是在阅读作业框架代码后才明白的。\n这一转换就相对简单许多：\n$$ M_{ortho} = M_{ortho-scale} \\cdot M_{ortho-transform} $$\n我们再来看左边的透视投影，他是一个梯形，实际上和正交投影很类似，也有六个面，还外带了一个视场角。我们可以先将透视投影的盒子转为正交投影的盒子，再做正交投影计算就能获得标准立方体。即： $$ M_{persp}=M_{ortho} \\cdot M_{persp\\rightarrow ortho} $$\n这里的 $M_{persp\\rightarrow ortho}$ 较为难求，不过也可以推导出来，复习主要是为后续实现rust栅格化渲染器做基础，此处就不做公式推导。直接给出变换矩阵：\n$$ M_{persp\\rightarrow ortho} = \\left[ \\begin{matrix} near \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\\\\n0 \u0026amp; near \u0026amp; 0 \u0026amp; 0\\\\\n0 \u0026amp; 0 \u0026amp; near+far \u0026amp; -near\\times far\\\\\n0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\end{matrix} \\right] $$\n算出模型在标准立方体中的坐标后即可按比例扩大为画面中的像素坐标，再做栅格化。\n栅格化 经过一系列变换我们获得了一堆模型坐标点在画面中的位置。\n 最基础的栅格化算法将多边形表示的三维场景渲染到二维表面。多边形由三角形的集合表示，三角形由三维空间中的三个 顶点表示。在最简单的实现形式中，栅格化工具将 顶点数据映射到观察者显示器上对应的二维坐标点，然后对变换出的二维三角形进行合适的填充。\n\u0026mdash;-WikiPedia\n 我们需要遍历像素点来判断该点是否在三角形内，在的话就使用该三角形的属性进行渲染。遍历难不倒码农。\n但问题在于如何判断点是否在三角形内呢？采用向量叉积的方法来判断。\n通过叉积可以判断两个向量的左右关系， $\\vec{a}\\times\\vec{b}$ 与 $\\vec{b}\\times\\vec{a}$ 是完全相反的结果，我们可以通过判断三角形三条边与顶点到某点的叉积来判断各自的左右关系，当左右关系完全一致则在三角形内。\n例如此图，$P_0$ 满足 $\\vec{V_{0}P_{0}}\\times\\vec{V_{0}V_{1}}$ / $\\vec{V_{1}P_{0}}\\times\\vec{V_{1}V_{2}}$ / $\\vec{V_{2}P_{0}}\\times\\vec{V_{2}V_{0}}$ 三者同正负，但 $P_1$ / $P_2$ 无法满足这一点。其中 $P_1$ 的叉积会有个是0 ，对于这种线上的情况就看栅格化渲染器自身处理了。\n为了优化遍历次数，可以先对三角形做包围盒后在包围盒中便利，对每一行的便利，也可先算出头尾再做遍历。\n抗锯齿 由于采样频率小于图像信号频率，会产生锯齿。\n这种失真常发生在物体边缘部分，像素采样对边缘部分高频信号采样不足导致走样。\n这有很多种解决办法，相信大家玩游戏的时候也都遇到过（开始抄Wikipedia）：\n 超级采样抗锯齿（Super-Sampling Anti-aliasing，简称SSAA）； 多重采样抗锯齿（Multisampling Anti-Aliasing，简称MSAA）是一种特殊的超级采样抗锯齿（SSAA）； 覆盖采样抗锯齿（Coverage Sampling Anti-Aliasing，简称CSAA）是nVidia G80系列出现时一并出现的抗锯齿技术； 可编程过滤抗锯齿（Custom Filter Anti-Aliasing，简称CFAA）技术起源于AMD-ATI的R600家庭； 快速近似抗锯齿（Fast Approximate Anti-Aliasing，简称FXAA）是由Timothy Lottes开发的一种反锯齿； 时间混叠抗锯齿（Temporal Anti-Aliasing，简称TXAA）是NVIDIA开发的抗锯齿技术，TXAA是为减少移动时的锯齿现象采用了不同时间帧的像素进行采样，跟前几样空间反锯齿比起来，TXAA大幅减少了移动中的破碎影像； 深度学习抗锯齿（Deep Learning Anti-Aliasing，简称DLAA）是利用位于远程的深度学习专用TPU的深度计算性能，预先运算大量的超级取样样本影像，再将样本影像与在本机端即时运算生成的影像进行差异比较，然后通过学习、观察其中的差距，来重新实现完成前者的影像质量，以达到抗锯齿成果，DLAA是一个需要远程资源与本地资源互相配合，协同工作产生抗锯齿效果的抗锯齿技术。  就这样我又水了不少字。都是算力换图像。\n举个我写的SSAA例子：\nfloat inside = (float)( insideTriangle((float)x + 0.0f/2, (float)y + 0.0f/2, v) + insideTriangle((float)x + 0.0f/2, (float)y + 1.0f/2, v) + insideTriangle((float)x + 1.0f/2, (float)y + 1.0f/2, v) + insideTriangle((float)x + 1.0f/2, (float)y + 0.0f/2, v)) / 4.0f;  在一个像素点(x,y)内做了做了四次“是否在三角形内”的判断，最后取得一个系数来取三角形属性。效果如下\n这一节课主要讲了信号与系统的知识，在此不做复习。\nZ-Buffer 对于多三角形的层叠渲染，这边的Z轴有了作用，用来判断深度。因此也需要多一个图像大小的buffer来存放当前已经算过像素点的深度，用于后续三角形判断是否覆盖。\n应该还有更好的方法。\n就这？只有颜色？ 不不不，懒得写了，下次再写详细的渲染与贴图。\n","date":1622983067,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1622983067,"objectID":"4381f6bebfd406691edd3bf8780533c5","permalink":"https://blog.morningtzh.com/post/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF.html","publishdate":"2021-06-06T20:37:47+08:00","relpermalink":"/post/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF.html","section":"post","summary":"图形学入门\u0026ndash;渲染管线 [TOC] 目录 渲染管线纵览 继续回顾变换 相机变换 投影及物体变换 栅格化 抗锯齿 Z-Buffer 就这？只有颜色？ 上次大致写了一下变换，那是","tags":["图形学","shader","变换"],"title":"图形学入门--渲染管线","type":"post"},{"authors":null,"categories":["图形学"],"content":"图形学入门\u0026ndash;变换 [TOC]\n目录  向量变换 齐次坐标 齐次坐标下的变换 三维变换   最近在学图形学，并顺手学个rust，用rust来做一个shader，实践之前需要在课后再深入复习一下。 图形学我看的是 闫令琪大神的 GAMES101: 现代计算机图形学入门,想要学习的话可以看看,视频在B站上也很方便.\n由于我是个初学者, 一年前开始接触unity3D和blender这些软件, 对三维世界有大致的了解, 因此会在我之前的理解上进行复盘. 同时一些示例图片会通过blender生成.\n向量变换 区别于图片的像素矩阵, 图形学的世界更类似于数学方程式. 对一个模型的描述, 通常使用由无数个三角形组成的面来表示, 将三角形分解, 就是三个点.\n对于点的描述可以表示成 $[x,y]^T$​ , 上面的转置是由于在图形学中一般点和向量习惯竖着写$\\left[ \\begin{matrix} x\\\\\ny \\end{matrix} \\right]$\n以下为四个点围成的正方形, 其中x和y都为1, $\\left[\\begin{matrix} 1\\\\\n1 \\end{matrix} \\right]$ ,并将其放到笛卡尔坐标系中.\n此时我们可以对做以下操作:\n 线性变换  基于原点的缩放 $$\\left[\\begin{matrix} x'\\\\\ny' \\end{matrix} \\right] = S_{(x,y)}\\cdot\\left[\\begin{matrix} x\\\\\ny \\end{matrix} \\right] = \\left[\\begin{matrix} s_x \u0026amp; 0\\\\\n0 \u0026amp; s_y \\end{matrix} \\right]\\cdot\\left[\\begin{matrix} x\\\\\ny \\end{matrix} \\right]$$ 基于原点的旋转 $$\\left[\\begin{matrix} x'\\\\\ny' \\end{matrix} \\right] = R_\\theta\\cdot\\left[\\begin{matrix} x\\\\\ny \\end{matrix} \\right] = \\left[\\begin{matrix} \\cos\\theta \u0026amp; -\\sin\\theta \\\\\n\\sin\\theta \u0026amp; \\cos\\theta \\end{matrix} \\right]\\cdot\\left[\\begin{matrix} x\\\\\ny \\end{matrix} \\right]$$   平移变换  平移 $$\\left[\\begin{matrix} x'\\\\\ny' \\end{matrix} \\right] = T_{(x,y)}+\\left[\\begin{matrix} x\\\\\ny \\end{matrix} \\right] = \\left[\\begin{matrix} t_x\\\\\nt_y \\end{matrix} \\right]+\\left[\\begin{matrix} x\\\\\ny \\end{matrix} \\right]$$    一个点的所有变换在笛卡尔坐标系下无法通过线性变换来表示,只能通过仿射变换来表示,就会产生一些麻烦,因此我们引入齐次坐标来将平移变换也转换为线性变换.\n齐次坐标 齐次坐标就是通过高维来表示地维的坐标.\n 二维点: $\\left[\\begin{matrix} x \\\\\ny \\\\\n1 ​ \\end{matrix} \\right]$ 二维向量: $\\left[\\begin{matrix} x \\\\\ny \\\\\n0 ​ \\end{matrix} \\right]$  我们可以看出,点和向量的唯一区别在于$z$是否为0，当$z$为0的时候是向量，为1的时候是点。\n可以简单验证一下：\n vector + vector = vector point - point = point point + vector = point  而 point + point 相加会发现最后一维变成了2，但这个问题不大，在图形学中齐次坐标的点有以下定义：\n$$ \\left( \\begin{matrix} x \\\\\ny \\\\\n\\omega \\end{matrix} \\right) = \\left( \\begin{matrix} x/\\omega \\\\\ny/\\omega \\\\\n1 \\end{matrix} \\right), \\omega\\not=0 $$ 因此 point + point = point 也成立。\n齐次坐标下的变换 我们同样可以在齐次坐标下进行变换\n 基于原点的缩放 $$\\left [\\begin{matrix} x' \\\\\ny' \\\\\n1 \\end{matrix} \\right] = S_{(x,y)}\\cdot\\left[\\begin{matrix} x \\\\\ny \\\\\n1 \\end{matrix} \\right] = \\left[\\begin{matrix} s_x \u0026amp; 0 \u0026amp; 0\\\\\n0 \u0026amp; s_y \u0026amp; 0\\\\\n0 \u0026amp; 0 \u0026amp; 1 \\end{matrix} \\right]\\cdot\\left[\\begin{matrix} x\\\\\ny\\\\\n1 \\end{matrix} \\right]$$ 基于原点的旋转 $$\\left[\\begin{matrix} x'\\\\\ny'\\\\\n1 \\end{matrix} \\right] = R_\\theta\\cdot\\left[\\begin{matrix} x\\\\\ny\\\\\n1 \\end{matrix} \\right] = \\left[\\begin{matrix} \\cos\\theta \u0026amp; -\\sin\\theta \u0026amp; 0\\\\\n\\sin\\theta \u0026amp; \\cos\\theta \u0026amp; 0\\\\\n0 \u0026amp; 0 \u0026amp; 1 \\end{matrix} \\right]\\cdot\\left[\\begin{matrix} x\\\\\ny\\\\\n1 \\end{matrix} \\right]$$ 平移 $$\\left[\\begin{matrix} x'\\\\\ny'\\\\\n1 \\end{matrix} \\right] = T_{(x,y)}+\\left[\\begin{matrix} x\\\\\ny\\\\\n1 \\end{matrix} \\right] = \\left[\\begin{matrix} 1 \u0026amp; 0 \u0026amp; t_x\\\\\n0 \u0026amp; 1 \u0026amp; t_y\\\\\n0 \u0026amp; 0 \u0026amp; 1 \\end{matrix} \\right] \\cdot \\left[\\begin{matrix} x\\\\\ny\\\\\n1 \\end{matrix} \\right]$$  这样一来，我们就能把这些变换都通过线性变换来表示了，可以通过连乘的方法来表示一些列变换。\n比如我们对为处于原点的方块进行以下操作。\n$\\Longrightarrow$ 对其进行分析我们可以发现这个变换包含了旋转和缩放，但由于我们上面讲到旋转和缩放都是基于原点的变换，我们无法直接套用上述公式，需要先将其平移至原点做处理后再平移回来。\n这需要我们做这样一串操作：\n$$T_{(-t_x, -t_y)} \\Rightarrow S_{(s_x, s_y)} \\Rightarrow R_\\theta \\Rightarrow T_{(t_x, t_y)}$$\n写成公式就是(从右往左运算) $$ p' = T_{(t_x, t_y)} \\cdot R_\\theta \\cdot S_{(s_x, s_y)} \\cdot T_{(-t_x, -t_y)} \\cdot p $$ $$ \\downarrow $$ $$ \\left[ \\begin{matrix} x'\\\\\ny'\\\\\n1 \\end{matrix} \\right] = \\left[\\begin{matrix} 1 \u0026amp; 0 \u0026amp; t_x\\\\\n0 \u0026amp; 1 \u0026amp; t_y\\\\\n0 \u0026amp; 0 \u0026amp; 1 \\end{matrix} \\right] \\cdot \\left[\\begin{matrix} \\cos\\theta \u0026amp; -\\sin\\theta \u0026amp; 0\\\\\n\\sin\\theta \u0026amp; \\cos\\theta \u0026amp; 0\\\\\n0 \u0026amp; 0 \u0026amp; 1 \\end{matrix} \\right] \\cdot \\left[\\begin{matrix} s_x \u0026amp; 0 \u0026amp; 0\\\\\n0 \u0026amp; s_y \u0026amp; 0\\\\\n0 \u0026amp; 0 \u0026amp; 1 \\end{matrix} \\right] \\cdot \\left[\\begin{matrix} 1 \u0026amp; 0 \u0026amp; -t_x\\\\\n0 \u0026amp; 1 \u0026amp; -t_y\\\\\n0 \u0026amp; 0 \u0026amp; 1 \\end{matrix} \\right] \\cdot \\left[\\begin{matrix} x\\\\\ny\\\\\n1 \\end{matrix} \\right] $$\n根据矩阵运算的结合律，我们可以先求 $T_{(t_x, t_y)} \\cdot R_\\theta \\cdot S_{(s_x, s_y)} \\cdot T_{(-t_x, -t_y)}$, 减少运算。\n此处要注意的是，矩阵运算不符合交换律。\n三维变换 三维变换与二维变换类似。\n 基于原点的缩放 $$\\left [\\begin{matrix} x' \\\\\ny' \\\\\nz' \\\\\n1 \\end{matrix} \\right] = S_{(x,y,z)}\\cdot\\left[\\begin{matrix} x \\\\\ny \\\\\nz \\\\\n1 \\end{matrix} \\right] = \\left[\\begin{matrix} s_x \u0026amp; 0 \u0026amp; 0\\\\\n0 \u0026amp; s_y \u0026amp; 0\\\\\n0 \u0026amp; 0 \u0026amp; s_z\\\\\n0 \u0026amp; 0 \u0026amp; 1 \\end{matrix} \\right]\\cdot\\left[\\begin{matrix} x\\\\\ny\\\\\nz\\\\\n1 \\end{matrix} \\right]$$ 平移 $$\\left[\\begin{matrix} x'\\\\\ny'\\\\\nz' \\\\\n1 \\end{matrix} \\right] = T_{(x,y,z)}+\\left[\\begin{matrix} x\\\\\ny\\\\\nz\\\\\n1 \\end{matrix} \\right] = \\left[\\begin{matrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; t_x\\\\\n0 \u0026amp; 1 \u0026amp; 0 \u0026amp; t_y\\\\\n0 \u0026amp; 0 \u0026amp; 1 \u0026amp; t_z\\\\\n0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{matrix} \\right] \\cdot \\left[\\begin{matrix} x\\\\\ny\\\\\nz\\\\\n1 \\end{matrix} \\right]$$  但在三维空间中，旋转是特殊的，因为它有三个轴，对每个轴的旋转我们只要忽略这一轴即可：\n X轴旋转 $$\\left[\\begin{matrix} x'\\\\\ny'\\\\\nz' \\\\\n1 \\end{matrix} \\right] = R_x\\theta\\cdot\\left[\\begin{matrix} x\\\\\ny\\\\\nz \\\\\n1 \\end{matrix} \\right] = \\left[\\begin{matrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\\n0 \u0026amp; \\cos\\theta \u0026amp; -\\sin\\theta \u0026amp; 0\\\\\n0 \u0026amp; \\sin\\theta \u0026amp; \\cos\\theta \u0026amp; 0\\\\\n0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{matrix} \\right]\\cdot\\left[\\begin{matrix} x\\\\\ny\\\\\nz\\\\\n1 \\end{matrix} \\right]$$ Y轴旋转 $$\\left[\\begin{matrix} x'\\\\\ny'\\\\\nz' \\\\\n1 \\end{matrix} \\right] = R_y\\theta\\cdot\\left[\\begin{matrix} x\\\\\ny\\\\\nz\\\\\n1 \\end{matrix} \\right] = \\left[\\begin{matrix} \\cos\\theta \u0026amp; 0 \u0026amp; \\sin\\theta \u0026amp; 0\\\\\n0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\\\n-\\sin\\theta \u0026amp; 0 \u0026amp; \\cos\\theta \u0026amp; 0\\\\\n0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{matrix} \\right]\\cdot\\left[\\begin{matrix} x\\\\\ny\\\\\nz\\\\\n1 \\end{matrix} \\right]$$ Z轴旋转 $$\\left[\\begin{matrix} x'\\\\\ny'\\\\\nz' \\\\\n1 \\end{matrix} \\right] = R_z\\theta\\cdot\\left[\\begin{matrix} x\\\\\ny\\\\\nz \\\\\n1 \\end{matrix} \\right] = \\left[\\begin{matrix} \\cos\\theta \u0026amp; -\\sin\\theta \u0026amp; 0 \u0026amp; 0\\\\\n\\sin\\theta \u0026amp; \\cos\\theta \u0026amp; 0 \u0026amp; 0\\\\\n0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\\\\n0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{matrix} \\right]\\cdot\\left[\\begin{matrix} x\\\\\ny\\\\\nz\\\\\n1 \\end{matrix} \\right]$$  在这里会发现其中Y轴的变换是特殊的，这是由于根据右手螺旋定则，XY可以推出Z，YZ可以推出X，但是XZ推出的是-Y，因此Y相反。\n同样我们这边也可以结合三轴旋转变换为： $$R_{xyz}(\\alpha\\beta\\gamma)=R_x(\\alpha)R_y(\\beta)R_z(\\gamma)$$\n更复杂一点可以通过罗格里格斯旋转公式求出基于任意从原点出发向量旋转后的点，此处不做展开。\n","date":1620526056,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1620526056,"objectID":"dc8f1234ad9e18e75a91ab2a405759d1","permalink":"https://blog.morningtzh.com/post/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E5%8F%98%E6%8D%A2.html","publishdate":"2021-05-09T10:07:36+08:00","relpermalink":"/post/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E5%8F%98%E6%8D%A2.html","section":"post","summary":"图形学入门\u0026ndash;变换 [TOC] 目录 向量变换 齐次坐标 齐次坐标下的变换 三维变换 最近在学图形学，并顺手学个rust，用rust来做一个shader","tags":["图形学","shader","变换"],"title":"图形学入门--变换","type":"post"},{"authors":null,"categories":["游戏开发"],"content":"【Unity是个好游戏】随机地形生成 [TOC]\n目录  前文提要 1.高度图 2.高度图随机生成 3.地块生成 4.结果预览   前文提要  【Unity是个好游戏】我想玩什么\n1.高度图 首先我们需要了解地形数据的表示方法。一般我们会用高度图来表示，高度图即一张每个像素点为高度的 bitmap。可以看到下面这张图是全球的高度图，他的位深为 8bit。\n如果有兴趣可以从 wikipedia 上下载原图，$21600*10800$ 大小的高度图仅 5.89M。对于这么大一张 Heightmap，我们是无法直接用的，需要对他进行切割，分块加载。每个像素点之间的距离是\n本次随机地形生成，高度图也会随机生成出来使用，当然随机生成的小模块也能替换为加载已有地形。\n高度图的渲染效果，下图为生成的 mesh：\n2.高度图随机生成 随机生成在一般的单值用法里，各个语言的Random库就有很好的支持。但对于地形图，他需要一个在2D 平面上连续的值。最简单的我们可以通过 $h=x+y$ 来遍历像素点生成高度图，这样简单地函数有利于我们在地形区块拼接不上时快速找到问题，当然也可以换成更单调的$h = x$ 或$h = y$ 来查看两轴上的拼接问题。\n在 Minecraft 地图采用 Perlin 噪声 生成。他会生成类似于以下的图像：\n将此图渲染成 mesh 就能得到我们想要的随机地形。\nPerlin 噪声较为连续，单一使用它会导致地形过于贫乏，因此在实际生成时会多层噪声叠加。\n接下来讲解的图来源于YouTube 大佬的地图生成教程 —— Procedural Terrain Generation 。这里简单的采用三层噪声进行讲解：\n 大地形：通过对噪声密集采样，获取较为平缓的波形； 巨石：通过对噪声的中等密度采样，获取一般的波形； 小石块：通过对噪声的大跨度采样，获取波动幅度最剧烈的波形；  最终将这三个波形进行叠加，就是一个不再单调的波形了。\n同时对这三种波形振幅进行一个加权，减少小石块对大地形的影响，就能得到一个比较合适的地形。\n这个教程我没看完，review 了他最终的代码，大致理解他生成地形的方法。这个教程中自建 mesh 创造地形，比我使用 Unity3D 自带的 Terrain 更为复杂和底层。\n3.地块生成 上图的波形其实也挺单调的，我并不想跑了一个小时之后还是类似的地形，因此需要作出一些差别。\n我们会发现在现实世界中其实是有地块划分的，平原、高原、丘陵等等。我们在游戏里也自然可以划分地块，对于不同的地块配置不同的地形参数。在划分地块的时候我们需要用到另外一个噪声—— Worley noise .\n这种噪声会形成类似昆虫翅膀、细胞壁等形状。同时也广泛用于水波生成。\n对这种噪声的转换，可以生成我想要的地块划分。以下使用 FastNoise生成~\n4.结果预览 后续的代码，将会融合以上的地形生成和地块生成。最终在不同区域上的地形差距可以非常大。可以看到带湖泊的平原后面是多重的高山，在这张图中间的山上有一处小 bug，会在后续详细介绍。\n","date":1603509116,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1603509116,"objectID":"099279c7df02c525bde285229d40f959","permalink":"https://blog.morningtzh.com/post/unity%E6%98%AF%E4%B8%AA%E5%A5%BD%E6%B8%B8%E6%88%8F%E9%9A%8F%E6%9C%BA%E5%9C%B0%E5%BD%A2%E7%94%9F%E6%88%90.html","publishdate":"2020-10-24T11:11:56+08:00","relpermalink":"/post/unity%E6%98%AF%E4%B8%AA%E5%A5%BD%E6%B8%B8%E6%88%8F%E9%9A%8F%E6%9C%BA%E5%9C%B0%E5%BD%A2%E7%94%9F%E6%88%90.html","section":"post","summary":"【Unity是个好游戏】随机地形生成 [TOC] 目录 前文提要 1.高度图 2.高度图随机生成 3.地块生成 4.结果预览 前文提要 【Unity是个好游戏】我想玩","tags":["Unity3D","游戏开发"],"title":"【Unity是个好游戏】随机地形生成","type":"post"},{"authors":null,"categories":["游戏开发"],"content":"【Unity是个好游戏】我想玩什么 [TOC]\n目录  之前玩了什么 那这次玩什么 选型   之前玩了什么 游戏制作，是一个一直想尝试的领域，毕业后几年一直有阶段性的尝试。\n刚毕业的时候比较喜欢 python。网上搜了 python 的游戏引擎，发现有pycocos2d、pygame，就选择了 pycocos2d 作为入门。这是最古老的 cocos2d 版本，基于pyglet，估计很少有人知道 cocos2d 最早竟然是仅支持 python 的。基于 pycocos2d，我用做了一个小场景，是一个小幽灵被一群大幽灵群殴。当时是用冒险岛素材做的，我小时候很喜欢冒险岛。由于当时编码能力非常弱鸡，理解能力也不足，后面就没继续了。\n 后面大概是两年之后了，玩着 Minecraft，突然想自己实现一下。那就先做个 2D 的吧，当时Cocos Creator是主推编辑器，正好那时候做 blog 用了 javascript，技术栈可以匹配，兄弟们用它！\n试图实现Minecraft 上的方块地图，用了四叉树和大量方块来做地图。从一开始的卡死到后面四叉树碰撞体融合，这次的游戏制作使用了柏林噪声生成二维地图。\n 那这次玩什么 这次又是一个两年后，得益于现工作认识了游戏开发大佬——在大学的时候就已经上线过一款游戏了，又燃起了游戏之魂。\n我玩游戏应该归在休闲党的行列。高中每周鲜有的游戏时间，大多数被我浪费在暴风城里，开着公会频道闲聊；在玩众多单机游戏时，我是挂逼，找不到挂就尝试修改存档；Minecraft 里面造造房子，飞到天上看看风景。\n所以这次玩什么？首先是他能给我带来什么。我期望的是一个开放自由的世界，有很多地方可供游览。\n游戏的丰富性至关重要，但我同样无法耗费大量时间来写剧本，另一方面自己写的剧本自己玩起来也缺乏新意。那丰富性只能通过随机值来获取了。\n这次玩的应该是一个随机世界，或者是一个RogueLike 游戏。\n 丰富的地形 建造系统 基础 RPG 系统  当然自己玩的乐趣主要在于游戏开发，游戏内的乐趣需要在开发的过程中慢慢丰富。从第三人的角度看起来，做出来的游戏一定会非常乏味。\n选型 在尝试过 cocos 系列的平台后，期望尝试一下3D 类型的游戏，这在制作过程中将会有更丰富体验。Unreal对我来说会太过沉重，同时我也没有很好的设备来支撑 Unreal 的开发。因此这次选择了 Unity3D 作为制作平台，抛开中国区的恶心运营来说，他是一个入门好平台。\n在 Unity3D 中，有一个自带的地形模块 Terrain，可以在上面方便的做出各种想要的地形。在初期的开发中也会主要围绕 Terrain 进行地形生成的开发。\n","date":1603502264,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1603502264,"objectID":"bd9c62491953f06ac2f5e48ab44bed35","permalink":"https://blog.morningtzh.com/post/unity%E6%98%AF%E4%B8%AA%E5%A5%BD%E6%B8%B8%E6%88%8F%E6%88%91%E6%83%B3%E7%8E%A9%E4%BB%80%E4%B9%88.html","publishdate":"2020-10-24T09:17:44+08:00","relpermalink":"/post/unity%E6%98%AF%E4%B8%AA%E5%A5%BD%E6%B8%B8%E6%88%8F%E6%88%91%E6%83%B3%E7%8E%A9%E4%BB%80%E4%B9%88.html","section":"post","summary":"【Unity是个好游戏】我想玩什么 [TOC] 目录 之前玩了什么 那这次玩什么 选型 之前玩了什么 游戏制作，是一个一直想尝试的领域，毕业后几年一直有阶段性的尝","tags":["Unity3D","游戏开发"],"title":"【Unity是个好游戏】我想玩什么","type":"post"},{"authors":null,"categories":["投资"],"content":"一单愚蠢的交易 [TOC]\n目录  交易日记 复盘 总结   近两年我也一直在投资 ETF，半年多前重新建仓，疫情期间也略微有些收益，最近更是收获颇多。\n最近在聊天群看别人在港美股收益巨大，特斯拉、阿里巴巴、中芯等股票都在翻倍，看的心痒痒。毕竟半年多25%的收益和半个月100%给人的感觉是天差地别的。\n交易日记 2020.7.13 中芯国际收盘于 41.95 港币；\n2020.7.14 开盘于 42 元，紧接着略微下跌了一点，当时主要想着先尝试成交一笔吧，在边上震荡卖出也不会亏很多，在 40.6 的时候挂单了一手 40。看着盘，下方挂单数在 40 有 2~3M 之多，突然觉得有些不对，如果这么多单子都被吃掉那肯定会继续下行啊。但等我准备撤单的时候已经来不及了。出现了一个小 v 型后最终收盘在了 41.8。当时并不太了解港股的特性以及他的交易时间，也并没有想太多。第一天就盈利了 900+ 块基本上冲昏了头脑；\n2020.7.15 高开在44 的位置，不过等我去看的时候已经降到了 41 元附近。当时也没想跑，在 40 徘徊时竟然还想着融资再买一手尝试做 T。吸收了前一日经验，关注了单子数量，39.3 的位置上 M 了，便挂在了 39.35 的位子上，最后在震荡中成交了。当天的走势一直在震荡，想到第二天会是 A 股中芯国际上市科创板的日子，也就先放着看情况了。最终收盘在 38.45，亏损了 2300。略微有些难过；\n2020.7.16 中芯开盘在 38.35 躺尸，A 股集合竞价开始102，涨到 110，最后到了 90 的位置结束。H股跟着集合竞价慢慢走到了 39 的位置。A股开盘后跌落到了 85，而 H 股狂泻，第一波达到了 32.65，反弹到 35 后开始第二波下降，融资开始提醒需要增加保证金，我也随手市价卖了一手，出在 32.1 自有资金先再放一会儿。到了下午继续震荡下挫，太可怕了，在 30 的位置卖掉了另外一手。当天亏损 8600+港币。\n复盘 中芯国际复盘还算是个简单的活，首先从技术层面来讲一讲。\n在这个 K 线图里可以看到我买的前一天是个绿色的倒 T 型，我买的那天是个T 型。顶部倒 T 预示着多头力量较为疲软，尤其是下方又多出了一点，最终以绿色收盘。我买的第一单 T 行有较长的尾巴，多头力量较前一天更加疲软，我再长影线上买进虽然赚了，但依然预示着多头已经耗尽，力量已经被空头压过。\n15 日的爆发我无法去分析，但应该是机构在逃顶了。\n从 RSI 来看，7.6、7.7，我打箭头的地方已经开始呈现力量减弱的现象，向上未到前面两峰的连线，向下突破了三个RSI6低谷的连线。后续几天三条 RSI 交叠在一起已无力支撑。\n消息面的利好在 7.7基本也消耗完毕，基本面从历史分析看来也是不佳。唯一的优势在于国家大力推动。这两方面比较复杂，我也不转述其他文章意见了。\n总结 就好像一个单身二十几年第一次交往异性似的热血上涌，抛开了—— 著作的训诫、蜡烛图技术、指标、量化模型——一切的外物，站到了哥斯拉面前，大吼到『我秃了』，送上了拳头。\n不知道为什么在那一刻我如此愚蠢，不带一丝恐惧的下单了。做 ETF 时的谨慎，策略的研究就像废物一样被我丢弃了。这次的交易在经济上的打击并不大，主要打击在于自己在市场前做出了毫无理智的行动，这非常可怕。\n投资需理性，任何的行动必须建立在策略的基础上。为什么买？为什么卖？买了什么时候补仓？卖了什么时候买回来？抛开理性，即使第一次好运赚到了钱，也会在后面亏得更多。\n接下来，重读经典，并做好笔记。甚至最近想考个 CFA 试试。\n 你永远赚不到\n超出你认知范围外的钱\n除非你靠运气\n但是靠运气赚到的钱\n最后往往又会靠实力亏掉\n这是一种必然\n你所赚的每一分钱\n都是你对这个世界认知的变现\n你所亏的每一分钱\n都是因为对这个世界认知有缺陷\n这个世界最大的公平在于：\n当一个人的财富大于自己认知的时候\n这个社会有100种方法收割你\n直到你的认知和财富相匹配为止\n ","date":1594910733,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1594910733,"objectID":"0e59abfa288abfb0a4e77fd6c1c848af","permalink":"https://blog.morningtzh.com/post/%E4%B8%80%E5%8D%95%E6%84%9A%E8%A0%A2%E7%9A%84%E4%BA%A4%E6%98%93.html","publishdate":"2020-07-16T22:45:33+08:00","relpermalink":"/post/%E4%B8%80%E5%8D%95%E6%84%9A%E8%A0%A2%E7%9A%84%E4%BA%A4%E6%98%93.html","section":"post","summary":"一单愚蠢的交易 [TOC] 目录 交易日记 复盘 总结 近两年我也一直在投资 ETF，半年多前重新建仓，疫情期间也略微有些收益，最近更是收获颇多。 最近在聊天群看别","tags":["投资"],"title":"一单愚蠢的交易","type":"post"},{"authors":null,"categories":["读书"],"content":"GTD 大纲 第一章结构梳理 |《GTD》     问题：增长的需求，匮乏的资源  工作不再有清楚的界限   工作（生活）不断变化   旧的模式和习惯已让人力不从心   『大局』和事物的本质     承诺：武术家的『一切就绪的状态』  心如止水   在需要时使自己进入『高效状态』     原则：有效地处理内心的承诺  管理承诺时的基本要求\n回顾\u0026amp;行动     过程：管理你的行动  自下而上的方法\n从当前活动和任务的最底层入手来处理事务——对提高个人工作效率最具实用价值。\n   对行动的横向管理及纵向管理   把一切事务赶出大脑     行动管理方式  横向控制\n横向控制是把你涉及的所有行动都管理起来，保证毫无遗漏地加以执行。\n  工作流程管理的五个步骤   收集收集我们注意的事务和信息  百分之百收集一切『未尽之事』   Tip: 影响成功收集的因素  把一切赶出大脑   用尽可能少的收集工具   定期清理收集工具       理清每个项目的意义和相关措施  他是什么？   是否需要采取行动？  不需要采取行动  无用的垃圾，无需保留   目前不需要，将来也许需要（孵化）   具有潜在有用信息，日后可能会用（参考）     需要采取行动  如果是个项目，列入项目清单   下一步需要采取的行动  立即执行。\n如果行动能在两分钟（自己确定阈值）内完成，那么就应该立即完成。​   指派他人\n如果自己不是最佳人选，就委托给一个合适的人员去处理   延迟处理\n记录在下一步行动清单上           组织整理结果，提出选项  项目\n任何一个需要多个步骤才能完成的任务\n  项目清单\n一种提醒自己还有事情尚未处理的机制   辅助性材料\n项目清单可以成为一个分门别类地存放项目材料文件夹的索引   辅助性资料和参考资料\n需要时常参考     下一步行动的归类  日程表  需要在某一指定时间里执行的行动\n标注在对应时间点上即可，例如会议   需要在指定日期执行的行动\n标注在日历中，💡可以在提醒事项中   需要在指定日期获取的信息\n💡提醒事项     不再需要『每日工作清单』\n无效化   『下一步行动』清单\n它和日程表一起，构成每日行动管理组织和导向的核心结构。\n     无需付诸行动的事务  垃圾\n没有行动价值或者参考价值   需要酝酿的资料\n无需立即行动，但仍希望保存 💡需要渐进明晰   『将来/也许』清单\n目前不打算试试，但又希望在将来某个时候处理   『备忘录』\n不愿去做，但需要在未来指定时间持续受到提醒   参考资料  按特定主题或领域分类存储系统   一般性参考资料归档系统         进行思考回顾  回归的内容和时机  每日回顾\n日程表、下一步行动清单等   定期回归\n项目、将来也许清单等     每周回顾  收集和加工处理所有材料   回顾整个系统   更新各类清单   做到彻底、清楚、实时和完整       选择行动  四标准法\n情境、有多少时间、有多少精力、重要性​   三分类法  执行事先安排好的工作   处理突发事件   安排自己的工作     六层次法  当前行动\n堆积的活动   当前项目\n当前需要完成的工作\n   关注点及责任范围\n你的兴趣及承担的责任和义务   目标\n1~2 年期望有什么样的局面   愿景\n展望未来 3~5 年的发展前景​​   目的及原则\n为什么存在？核心意义           纵向管理\n对每个具体的主题或项目进行思考和协调，并跟踪其进展情况。\n简式计划​  非自然计划模式\n在试图处理某一问题是，并不遵循大脑运作的自然规律，那么问题就不那么容易解决。   反应式计划模式\n无计划，临时应变。会造成巨大风险   自然计划模式\n跟随大脑的计划，大脑自然而然地做了一下步骤\n1、定义目标和原则\n2、展望结果\n3、头脑风暴/集思广益\n4、组织整理\n5、明确下一步的行动方案​​​​​​  目标\nWhy?  界定成功\n人们喜欢赢，但如果你对自己的行动目标不是一清二楚的话，你将失去获胜的机会​   建立决策标准\n通常，做出一个艰难决策的唯一途径就是，回到目标上来。   调配资源   激发动机\n如果你对自己行为的动机缺乏清醒的认识，你就不可能尽力而为。   阐明重点\n当你紧紧抓住了你工作的真正米表示，一切就变得一目了然了。​   扩宽选择\n当目标精确地定位了工作中心时，他也同时开启了人们创造性思维的大门。\n     原则\n你所遵循的标准和价值观，与推动和指导工作发展进程的目标一样，具有同样的价值。\n目标赋予我们十足的干劲，原则界定了我们行动的限制因素以及行为的标准。​   前景/结果\nWhat?  聚焦的力量\n我们头脑中坚持不懈遵循的信念，能够影响我们对外界的观感以及我们的具体表现。\n想象力比知识更重要​   网状激活系统\n当大脑中产生了一个清晰的镜像，描绘出渴望的食物，并专注于这个食物是，你的大脑就会自动帮你捕获生活中的相关信息了。   阐明结果\n在知识工作的领域中，最有效的生活技能之一就是创造出清晰可见的结果，这也是我们为了实现职业和个人成功需要进行艰苦磨炼的重要技能之一。\n     头脑风暴/集思广益  捕捉想法  思维导图（mind-mapping）   集结法（clustering）   仿制法（patterning）   结网法（webbing）   鱼骨图（fishboning）     分布式认知\n将信息从大脑中清理出去，转化为客观的。可以经常回顾的形式----建立一个外脑。   头脑风暴的关键技巧  不判断/不质疑/不评估/不批判   追求数量/不求质量   把分子组织工作置于次要的地位       组织整理  明确事情的重要组成部分   整理分类   构成因素   先后顺序   重要程度   足够详细的描述     下一步行动\n决定如何分配和再分配各种资源，以推动工作的顺利进行          ","date":1594821466,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1594821466,"objectID":"5c17d9cfa0d580605e20f43d54fdd764","permalink":"https://blog.morningtzh.com/post/gtd-%E5%A4%A7%E7%BA%B2.html","publishdate":"2020-07-15T21:57:46+08:00","relpermalink":"/post/gtd-%E5%A4%A7%E7%BA%B2.html","section":"post","summary":"GTD 大纲 第一章结构梳理 |《GTD》 问题：增长的需求，匮乏的资源 工作不再有清楚的界限 工作（生活）不断变化 旧的模式和习惯已让人力不从心 『大局』和事","tags":["GTD"],"title":"GTD 大纲","type":"post"},{"authors":null,"categories":["project"],"content":"B站云养鱼\u0026ndash;贫穷定制 目录  1. 我买了一个缸 2. 直播方案比较及限制条件  2.1 方案比较及场景限制 2.2 硬件限制条件分析   3. 整体方案设计  3.1 整体方案 3.2 视频源 3.3 视频目的地   4. 背景知识  4.1 流媒体 4.2 ffmpeg   5. 功能设计  5.1 视频列表 5.2 音乐播放列表 5.3 ffmpeg 命令生成 5.4 执行 ffmpeg 命令 5.5 半夜回放机制 5.6 直播退出机制 5.7 深夜直播暂停事件 6. 存在的问题   7. 可替代方案  7.2 网络摄像头支持 RTSP 7.3 手机   8. 关键决定因素   [TOC]\n1. 我买了一个缸 过年前散步，正好路过花鸟市场。本来打算买些花草，走着走着就变看鱼了。心血来潮，赶紧研究了下养鱼入门知识，并开了个一个草缸。\n新手的缸总是这么枯燥。\n缸还在路上的时候我就突然想开个直播，这么有趣的事情应该和大家分享。顺便赚点饲料钱，说不定还能靠直播当上 CEO 迎娶白富美。\n如此一来原始需求就定下了，需要做一个 24H 鱼缸直播方案出来。\n2. 直播方案比较及限制条件 2.1 方案比较及场景限制 项目是为创造独特产品、服务或成果而进行的临时性工作。1 这个直播需求与真人 UP 主的直播由于工作方式不同，因此会导致环境差异较大。\n 一般直播时，直播主体主播唯一受众为用户。无论是在线聊天、游戏还是云画画，直播的主机即为工作的主机，在一定时间段内，主播会面对主机进行工作，并通过这台主机直播出去，工作内容可以说就是直播内容； 本次直播时，直播主体鱼缸有两个受众，一个是直播用户，另一个是现场观众我我我！！！。对鱼缸进行24H 直播时不能让主机在空间中明显可见，这会阻碍现场观众视线；同时当我需要在一台主机上做直播无关工作，甚至开关机时不能影响直播进行。因此需要在隐蔽角落放一个独立主机进行直播。  Usecase:\ngraph LR subgraph 工作室 主播 --do--\u0026gt; 工作Process 主播 --被摄--\u0026gt;直播Process subgraph 主机 工作Process --被摄--\u0026gt; 直播Process end end 直播Process --推流--\u0026gt; B站  graph LR subgraph Home 鱼缸 --被摄--\u0026gt; 直播主机 鱼缸 --观赏--\u0026gt; 我 我--工作--\u0026gt;工作主机 end 直播主机 --推流--\u0026gt; B站  结合家里设备具体差异如下：\n    一般 UP 主 本次直播需求     时间 限时直播 24H 直播   主机 无需独立主机 需要独立主机   主机可见 需操作，可见 无需操作，不可见   操作系统 Windows Linux   摄像头 USB 摄像头 网络摄像头    2.2 硬件限制条件分析 由于穷，本次方案只能在家里现有设备基础上进行设计。\n目前可用设备：\n 蜗牛星际 AreYouOK 智能摄像机（第三代） Raspberry Pi Zero W  蜗牛星际是咸鱼上 300 块买来的矿难机，4G 内存，搭载 J1900 CPU，四盘位机箱，真香 😙。被我装上了 manjaro 做NAS 用，用来做下载、时间胶囊、物联网、数据可视化等功能。蜗牛星际被我藏在鞋柜里，满足了本次直播方案主机隐蔽的需求。\nAreYouOK 智能摄像机（第三代）是半年前买的，也是在研究直播系统的时候才了解了他的版本。AreYouOK 智能摄像机第二代是绝对的香，可以修改固件增加 rtsp 功能，第三代就不行了，试了很长时间都没法打开 rtsp，同时第三代在图像质量上也比第二代下降了很多。由于不能用 rtsp，我会在下文讲解别的方法。\nRaspberry Pi Zero W，做备选方案，这是我买来黑 USB 和 wifi玩的设备，他的优点在于蓝牙 wifi 都在一片上集成了，体积小，可以变成 USB 棒。\n下图是我自己的**Raspberry Pi Zero W*，加上了E-ink 屏幕和 USB 转换头。玩法非常多，比如模拟成两个设备，一个优盘一个键盘，就可以在插入PC 后通过蓝牙或 wifi 输入相应指令了；也可以通上电连上 wifi，做中间人攻击；其他的由于体积小，作为嵌入式主控也是不错的选择。\n3. 整体方案设计 3.1 整体方案 整体方案采用网络摄像机+NAS 推流的形式展开。OBS 获取 rtsp 流后，再通过 rtmp 丢到 B 站即可，轻松加愉快。\n不，事实并不是这样的。生活往往并没有这么容易😢 ，很容易接受现实的吊打。但我们还是先将我们的部署图画出来。\ngraph LR subgraph 鞋柜 NAS end subgraph 客厅 鱼缸 -- 拍摄 --\u0026gt; 摄像机 摄像机--传输视频--\u0026gt;NAS end NAS --推流--\u0026gt; B站  3.2 视频源 视频来源由于贫穷，首先选择现有的AreYouOK 智能摄像机。他是没有 rtsp、onvif 的辣鸡摄像机，但我们在 App 设置里面可以看到它支持 NAS，可以实时将视频保存到 NAS 上。我本以为这是一个黑科技，但万万没想到\u0026hellip;\n一定是我打开方式错误，我换个方式重新打开一下：\n➜ xiaomi_camera_videos tree . ├── 04cf8cfe7133 │ ├── 2020031908 │ │ ├── 16M12S_1584576972.mp4 │ │ ├── 17M10S_1584577030.mp4 │ │ ├── 18M10S_1584577090.mp4 │ │ ├── 19M10S_1584577150.mp4 │ │ ├── 20M10S_1584577210.mp4 │ │ ├── 21M10S_1584577270.mp4 │ │ ├── 22M10S_1584577330.mp4 ...  叮 本项目由于不可抗力终止。。。\n。\n。\n。\n。\n不 我当然是不会放弃的！不就是分钟级视频文件么。一定能解决！如果一些这么顺利，就没必要做脚本了。\n3.2.1 视频播放+OBS 通常主播在直播的时候会用到 OBS2，一款开源直播软件，B 站直播姬就是基于 OBS 制作的。它支持 macOS、linux和windows三个平台，可以在单个窗口添加不同的源合成一个画面，同时支持多场景切换。\nOBS 在不同场景的直播中都能发挥很大作用。画面来源支持非常多，rtsp、窗口捕获、桌面捕获、图像、视频、浏览器、音频、文字等等。有兴趣的可以下载一个，并参考 WiKI。\nOBS 是无法播放文件夹的，因此考虑采用视频播放器+OBS 的窗口捕获，获取视频流。\n最终由于 CPU 100% Good Game。\n同时也意识到了蜗牛星际 J1900 CPU 在视频编解码上的无力，无法使用 OBS 这样复杂的直播软件。\n3.2.2 ffmpeg 合成视频 ffmpeg 是一个非常棒的软件，他可以将播放列表作为Input 使用。因此本方案最终使用了ffmpeg 作为视频合成及推流工具。\n3.3 视频目的地 我们通过 ffmpeg 处理视频源，自然也通过 ffmpeg 来推流。\n4. 背景知识 为了后续更好理解整套方案，这边将对一些背景知识做一些简单的介绍\n4.1 流媒体 对于媒体编码、封装格式和传输协议本身其实和我们要做的方案关联较小，仅在定位一些问题时可能会用到比较深入的知识。\n在这里我们只需要简单的做些了解。\n4.1.1 视频编码 H.264  H.264，又称为MPEG-4第10部分，高级视频编码（英语：MPEG-4 Part 10, Advanced Video Coding，缩写为MPEG-4 AVC）是一种面向块，基于 运动补偿的 视频编码标准 。到2014年，它已经成为高精度视频录制、压缩和发布的最常用格式之一。第一版标准的最终草案于2003年5月完成。\n—— WikiPedia H.264\n H.264我们首先需要关注他是一种视频编码，他会对原始视频做大量压缩处理来减少视频的体积，其次是他有三种帧：\n I帧：关键帧，采用帧内压缩技术。 P帧：向前参考帧，在压缩时，只参考前面已经处理的帧。采用帧音压缩技术。 B帧：双向参考帧，在压缩时，它即参考前而的帧，又参考它后面的帧。采用帧间压缩技术。  缺少某一 I 帧时，画面会变得非常诡异，大家在看D 版电影时也经常会看到各种灵异的现象就是缺帧导致的。\n4.1.2 媒体封装格式 MP4  MP4或称** MPEG-4第14部分**（英语：MPEG-4 Part 14）是一种标准的数字 多媒体容器格式。MPEG-4第14部分的扩展名为**.mp4**，以存储 数字音频及 数字视频为主，但也可以存储 字幕和静止图像。因其可容纳支持 比特流的视频流（如 高级视频编码），MP4可以在网络传输时使用 流式传输。\n—— WikiPedia MP4\n 在上述 WikiPedia 的描述中，MP4 是一种容器，他会在里面存放音频、视频、字幕或图像，都是以通道来表示一路媒体的。\n4.1.3 流媒体协议 RTMP B 站采用 RTMP 方式推流，这是一种媒体传输协议。\n 实时消息协议（英语：Real-Time Messaging Protocol，缩写RTMP）也称实时消息传输协议，是最初由 Macromedia为通过 互联网在 Flash播放器与一个 服务器之间传输 流媒体 音频、 视频和数据而开发的一个 专有协议。Macromedia后被 Adobe Systems收购，该协议也已发布了不完整的规范供公众使用。\nRTMP协议有许多变种：\n 默认使用TCP端口1935的纯粹（plain）协议。 RTMPS，通过一个 TLS/SSL连接传输RTMP。 RTMPE，使用Adobe自有安全机制加密的RTMP。虽然实现的细节为专\u0026gt;有，但该机制使用行业标准的 密码学原函数。[ 1] RTMPT，用 HTTP 封装以穿\u0026gt;透防火墙。RTMPT通常在 TCP 端口80和443\u0026gt;上使用明文请求来绕过大多数的公司流量过滤。封装的会话中可能携带纯粹的\u0026gt;RTMP、RTMPS或RTMPE数据包。 RTMFP, 使用 UDP而非TCP的RTMP，取代RTMP Chunk Stream。Adobe Systems\u0026gt;开发了安全的 实时媒体流协议包，可以让最终用\u0026gt;户直接地相互连接（P2P）。  虽然RTMP的主要动机是成为一个播放Flash视频的协议，但它也用于其他一些应用程序，如 Adobe LiveCycle Data Services ES。\n—— WikiPedia 实时消息协议\n 4.1.4 以上三者之间的关系 当我们有一段原始视频时，首先我们会将其转成 H.264编码，这会减少很多空间。其次我们会加上音轨，这样就组成了有一个视频通道，一个音频通道的多媒体组合。\n我们可以看一下原始的电影胶片，他包含了多条轨道，杜比左右声道及其他音轨就和视频轨道并列存放着，这和 MP4 中的封装是差不多的。\n对于流媒体传输协议，里面包含的也是 H.264编码，可以将其看成将影片切成一段段发送。\n4.2 ffmpeg  A complete, cross-platform solution to record, convert and stream audio and video.\n—— FFmpeg\n 它有两种使用方式：\n 命令行：直接运行 ffmpeg 程序，并将命令作为运行参数传入即可； 库：通过库来使用灵ongn  我们在这个项目中主要采用命令行模式来调用 ffmpeg，这对一个小项目而言非常快速。\n5. 功能设计 5.1 视频列表 对于AreYouOK 智能摄像机输出到 NAS 上的文件来看，他是有规律的，每分钟保存一次。\n➜ xiaomi_camera_videos tree . ├── 04cf8cfe7133 │ ├── 2020031908 │ │ ├── 16M12S_1584576972.mp4 │ │ ├── 17M10S_1584577030.mp4 │ │ ├── 18M10S_1584577090.mp4 │ │ ├── 19M10S_1584577150.mp4 │ │ ├── 20M10S_1584577210.mp4 │ │ ├── 21M10S_1584577270.mp4 │ │ ├── 22M10S_1584577330.mp4 ...  他的格式为/{年月日时}/{分M秒S_时间戳}.mp4，根据文件名我们就能找到每个时刻的视频了。方案大致有两种：\n 寻找上一分钟的文件名，并进行播放； 寻找前几分钟的文件名，组合后进行播放。  两种方式各有利弊，第一个在设备时间无法同步时会造成找不到视频的现象，第二种方式会产生非常大的延时。\n但实际上对于直播用户来说，直播主体并不会和用户进行互动，因此延时不会造成实质的影响。最终我采用的是第二种方式。\n生成播放列表函数入参有两个，一个是持续时间，第二个是列表结束时间。函数中首先过滤了文件夹名，然后通过文件名末尾的时间戳比对出需要播放的文件，排序后写入播放列表中。同时需返回播放个数。\ndef make_video_list(during: int, endtime: datetime.datetime = datetime.datetime.now()): starttime = endtime - datetime.timedelta(minutes=during) print(\u0026quot;======Make Video List======\u0026quot;) print(\u0026quot;PlayList from {st} to {et}\u0026quot;.format(st=starttime, et=endtime)) def dir_filter(dir: str) -\u0026gt; bool: try: dir_time = int(dir) # strptime(dir, \u0026quot;%Y%m%d%H\u0026quot;) if dir_time \u0026gt;= int(starttime.strftime(\u0026quot;%Y%m%d%H\u0026quot;)) and dir_time \u0026lt;= int( endtime.strftime(\u0026quot;%Y%m%d%H\u0026quot;) ): return True else: return False except Exception as a: print(\u0026quot;make_video_list dir_filter Error \u0026quot;, a) return False # filter play list file_list = [] for dir in filter(dir_filter, os.listdir(CAMERA_PATH)): for file in os.listdir(CAMERA_PATH + dir): time = datetime.datetime.fromtimestamp(int(file[-14:-4])) print(\u0026quot;File : \u0026quot;, dir, file, end=\u0026quot;\u0026quot;) if time \u0026gt;= starttime and time \u0026lt;= endtime: file_list.append(CAMERA_PATH + dir + \u0026quot;/\u0026quot; + file) print(\u0026quot; Will Play\u0026quot;) print(\u0026quot; \u0026quot;) # write video playlist with open(VIDEO_PLAYLIST, \u0026quot;w\u0026quot;) as f: f.writelines( map( lambda path: \u0026quot;file '\u0026quot; + path.replace(\u0026quot;:\u0026quot;, \u0026quot;\\\\:\u0026quot;).replace(\u0026quot;'\u0026quot;, \u0026quot;\\\\\\\\\\\\\\\\\\\\\\\\'\u0026quot;) + \u0026quot;'\\n\u0026quot;, sorted(file_list), ) ) print(\u0026quot;======Make Video List End======\u0026quot;) return len(file_list)  5.2 音乐播放列表 合成视频的同时我们得把声音给删了，不然直播出奇怪的声音是会被封号的！！！\n这边通过对音乐文件夹随机排序来生成，这个时间将远大于视频播放的时间，因此我们需要有音乐的时间记录，第二段视频播放时音乐从上次播放的位置插进去。\ndef make_music_list() -\u0026gt; int: global g_music_play_time if g_music_play_time \u0026gt; MUSIC_MAX_TIME: print(\u0026quot;Will Create New Audio PlayList\u0026quot;) g_music_play_time = 1 # remake music play list music_list = list( filter( lambda file: file[-4:] == \u0026quot;.mp3\u0026quot;, map(lambda filename: MUSIC_PATH + filename, os.listdir(MUSIC_PATH)), ) ) random.shuffle(music_list) with open(AUDIO_PLAYLIST, \u0026quot;w\u0026quot;) as f: f.writelines( map( lambda path: \u0026quot;file '\u0026quot; + path.replace(\u0026quot;:\u0026quot;, \u0026quot;\\\\:\u0026quot;).replace(\u0026quot;'\u0026quot;, \u0026quot;\\\\\\\\\\\\\\\\\\\\\\\\'\u0026quot;) + \u0026quot;'\\n\u0026quot;, music_list, ) )  这边由于音乐是从我的播放器里拷贝的，额外过滤了文件类型，只采用 mp3 文件。\n同样写入文件中，此处由于音乐名称的复杂性，额外做了 escape。\n5.3 ffmpeg 命令生成 有了以上两个函数，基本功能基本完成，就差推流了。\n推流采用 ffmpeg，比较复杂，先上代码再慢慢讲解：\n# 生成命令行 ffinput = 'ffmpeg -y -re -loglevel warning -f concat -safe 0 -i \u0026quot;{VIDEO_PLAYLIST}\u0026quot; -ss {MUSIC_START_TIME} -f concat -safe 0 -i \u0026quot;{AUDIO_PLAYLIST}\u0026quot; -c copy -shortest '.format( VIDEO_PLAYLIST=VIDEO_PLAYLIST, AUDIO_PLAYLIST=AUDIO_PLAYLIST, MUSIC_START_TIME=get_music_start_time(), ) ffoutput = '-f flv \u0026quot;{RTMP_ADDR}\u0026quot;'.format(RTMP_ADDR=RTMP_ADDR) # ffoutput = \u0026quot;re.mp4\u0026quot; cmd = ffinput + ffoutput  这边采用了播放列表作为源，我们可以看-f concat -safe 0 -i \u0026quot;{VIDEO_PLAYLIST}\u0026quot; ，\n -f: fmt (input/output) 强制定义格式 concat： 连接，一种 demuxer，将源连接起来 -safe 0：concat 时不在意文件名 -i：input  我们将播放列表作为 concat 的输入，最后 concat 作为一个完整输入存在。\n音频输入也同样，这边增加了一个 -ss 是seek到这个时间作为开始的意思，音频播放列表时间太长了，为了每次推流没有断层的感觉，会每次累计播放时间，然后通过-ss指定播放位置。-ss是需要特殊格式的，因此我们通过函数生成。\ndef get_music_start_time(): global g_music_play_time return \u0026quot;{0:02}:{1:02}:{2:02}\u0026quot;.format( int(g_music_play_time // 3600), int((g_music_play_time % 3600) // 60), int(g_music_play_time % 60), )  我们再来看看ffinput最前一段和最后一段：\n -y : 强制覆盖写入 output； -re : 读取input 按实际帧率来，直播需要用指令，不然会以最快速度处理数据； -loglevel warning：日志级别 -c copy：不处理媒体编码，直接从 input 拷贝到 output，减少编解码的性能需求，当然这个同时我们没法对视频进行处理。 -shortest: 输出时长按最短的轨道来。  ffmpeg 在轨道重复时（例如视频音轨和音乐），会自动采用后输入的轨道。如果需要自定义就需要在指令上进行标示了。\n接下来我们看看ffoutput, 非常简单 -f flv \u0026quot;{RTMP_ADDR}\u0026quot; 制定了输出格式为 flv，并给了相应的 rtmp 地址。\n5.4 执行 ffmpeg 命令 ffmpeg 是系统二进制程序，因此我们需要在系统上调用它，通过 Popen在shell 环境下运行这条命令即可，同时等待结束，并接收输入输出。\n# 运行 cmd_proc = subprocess.Popen( cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, ) cmd_proc.wait() outs, errs = cmd_proc.communicate(timeout=1)  到这边一次几分钟的推流就完成了，我们循环这个动作就能持续不断的将新录制的视频推出去。\n5.5 半夜回放机制 除了白天鱼缸开灯期间的直播，我还期望在未开灯的时候也进行直播。当然我会关闭摄像头，防止在鱼缸背景较亮的情况下出现奇怪的反光，当然，半夜摄像头根本看不到什么，夜晚摄像头红外会被鱼缸玻璃反光形成强烈的光斑，无法观赏。\n我们需要在水草灯未工作期间进行直播就只能采用回放了，另外由于过年期间我个人的作息不定，只能通过软件自动检测是否工作了。\n这边的机制非常简单，当生成视频播放列表返回 0 时就可以进行回放了。此时我们将时间回退到 8~20 点之间，随机一个时间段，播放时间=当前时间-（当前小时-随机小时数） ，采用这个公式，当天关闭摄像头后可以播放指定时间段随机的时间点，但我们会发现超过半夜十二点后变为了 1 点-16 点 这样诡异的时间，反而变为了播放未来十五个小时后的视频。因此我们需要判断一旦过了半夜，相减的小时数就要多加 24h。\ntmp_endtime = play_endtime - datetime.timedelta( hours=( play_endtime.hour - random.randint(*CAMERA_WORKTIME) + (24 if play_endtime.hour \u0026lt; 12 else 0) ) )  这样就能24H 进行播放了，每次播放一小时的视频（看之前的函数，可以传入时长）。\n但如果随机 20 次还没视频的话，就会直接播放当前时间前 24H 所有视频了。还是没有视频就 sleep 一小时，当然到了这地步 B 站早就自动关停直播室了。\n5.6 直播退出机制 在实际调试过程中会发现很恼火的一点是 Ctrl+C 完全没有反应。由于展示在 shell 上的是 ffmpeg 进程，Ctrl+C只会退出 ffmpeg，而不会退出 python 脚本，此时他会在人类无法反映的时间内重启 ffmpeg。除了关闭 Shell，没什么更快捷的办法了。\n另外在 kill 时也会有需要先 kill 脚本，再 kill ffmpeg。\n后面很无奈，只能做一个直播退出机制了。将之前简单的 os.System 函数替换为了现在可控的subprocess.Popen 并增加了信号捕获。\ndef stop(signal, stack): # TODO: 此处必然有时序问题，暂不处理 nonlocal run run = False cmd_proc.kill() signal.signal(signal.SIGTERM, stop) signal.signal(signal.SIGINT, stop)  收到信号，暂停循环，并杀死 ffmpeg。\n5.7 深夜直播暂停事件 过年时每天起来会发现我的直播停了。当然我也懒得看日志，因为这件事太迷了，看日志也得翻好久。\n同上，后面很无奈，还是慢慢翻了日志。发现 ffmpeg 在断网后会卡死很长一段时间，需要二十多分钟才会退出。这个时间足够 B 站把我踢下线了。而断网的原因是我在路由器上设定了每天半夜清理缓存。（这竟然会断网，辣鸡 tplink。）\n然后就新增了一个进程，用于检测网络是否正常，这个进程是每五秒执行系统命令 ping 一次114，记录flag，并在恢复时 kill一次ffmpeg。\ndef ping(): nonlocal run global cmd_proc pre_state = True while run: state = True outs = subprocess.Popen( \u0026quot;ping -c 1 -w 1 114.114.114.114\u0026quot;, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, encoding=\u0026quot;utf8\u0026quot;, ).stdout.readlines() state = 0 == outs[-1].find('rtt') if not state: print(\u0026quot;Net broken!\u0026quot;) if False == pre_state and True == state: print(\u0026quot;Net resumed, kill cmd\u0026quot;) if None != cmd_proc: print(\u0026quot;Net resumed, kill cmd！！\u0026quot;) cmd_proc.kill() pre_state = state sys.stdout.flush() time.sleep(5) multiprocessing.Value ping_subproc = multiprocessing.Process(target=ping) ping_subproc.start()  至于为什么上面写的是进程\u0026hellip;那是 python 解释器的问题，由于GIL （全局解释器锁）的存在，多线程处理时非常低效，开了多线程也和没开一样，甚至更慢。\n6. 存在的问题 6.1 摄像机部署问题 摄像机拜访存在很大问题，会遮挡视线。并且作为监控摄像头来拍摄鱼缸是非常糟糕的，首先它存在非常大的镜头畸变，在近距离非常明显，其次广角镜头在拍摄近距离物体时难以对焦，导致画面较为模糊。\n6.2 时间戳问题 推流的 RTMP 协议中会增加相对时间戳，此时几分钟的视频播放完毕重启 ffmpeg 播放下一段时会重新生成时间戳，导致用户接收到的数据时间戳突变，容易导致播放问题。\n在Bilibili App 上很少存在断流的问题，但在Safari 上很容易断流。\n当然应该是可以通过 ffmpeg 的时间戳来解决的，不过是一个巨大的坑。也可以通过增加延迟，播放前一个小时的视频规避这个问题。\n6.3 视频重复问题 视频重复在刚开始直播时会容易出现，一开始视频不足 10 分钟，会取前几分钟的，播放完后会重新获取，此时之前几分钟的依然会被获取到，重新播放。\n7. 可替代方案 写了这段代码的主要原因在于AreYouOK 智能摄像机不支持 RTSP，一旦 RTSP 问题解决，代码就没有了存在意义。替代方案还是很多的\n7.1 PC+USB 摄像头\n购买一台冥王峡谷+罗技摄像头即可解决隐蔽性和以上所有问题。强大的 CPU 还能支持视频编解码，直接使用 OBS 玩更多直播内容。预计成本 10000.\n7.2 网络摄像头支持 RTSP 有一个支持 RTSP 的网络摄像头，可以将 python 脚本简化为 shell 脚本一键运行。\n7.3 手机 买一个二手手机 Bilibili App 进行直播，预计费用 300~500。最方便的办法，但扩展性不高。\n8. 关键决定因素 内容高于技术。无论是脚本、摄像头还是整套方案，最终都是为内容服务的。\n  www.pmi.com\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://obsproject.com\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":1584755386,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1584755386,"objectID":"23692947b88f066d1b8c8a9ab11eb1da","permalink":"https://blog.morningtzh.com/post/b%E7%AB%99%E4%BA%91%E5%85%BB%E9%B1%BC-%E8%B4%AB%E7%A9%B7%E5%AE%9A%E5%88%B6.html","publishdate":"2020-03-21T09:49:46+08:00","relpermalink":"/post/b%E7%AB%99%E4%BA%91%E5%85%BB%E9%B1%BC-%E8%B4%AB%E7%A9%B7%E5%AE%9A%E5%88%B6.html","section":"post","summary":"B站云养鱼\u0026ndash;贫穷定制 目录 1. 我买了一个缸 2. 直播方案比较及限制条件 2.1 方案比较及场景限制 2.2 硬件限制条件分析 3. 整体方案设计 3.1 整体方案 3.2 视","tags":["云养鱼","Bilibili","rtmp","ffmpeg"],"title":"B站云养鱼--贫穷定制","type":"post"},{"authors":null,"categories":["乐理"],"content":"乐理笔记1\u0026ndash;音程 目录  1. 音 2. 泛音列与音色 3. 音程 3.1 一度和八度 3.2 大小二度 3.3 大小三度 3.4 纯四度及增四度 3.5 纯五度及减五度 3.6 大小六度和大小七度 3.7 音程总结   本系列文章用于总结目前学习到的乐理知识。\n1. 音  声音是振动产生的 声波，通过 介质（ 气体、 固体、 液体）传播并能被人或动物 听觉 器官所感知的 波动现象。\n声音的频率一般会以 赫兹表示，记为Hz，指每秒钟周期性震动的次数。而 分贝是用来表示声音强度的单位，记为dB。\n—— wikipadia\n 其中标准音为 440HZ，定义为 A，位于中央 C 之上第一个 A，在键盘上为 A4。\n2. 泛音列与音色 假设某一个弦可以产生 100HZ的基波，那么他其实还会分段震动。由于驻波原理（两个 波长、 周期、 频率和波速皆相同的 正弦波相向行进 干涉而成的合成波）他们和基波的震动频率是倍数关系。\n如果某个弦的基波为 110HZ，那么他的泛音列为 220HZ、330HZ、440HZ。。。\n不同音源的音色不同就是源于泛音列强弱的不同。 我们可以听见某两样乐器的音高是相同的，那是因为基音是强度最强的音，而后音色是通过泛音列不同频率声波的强度特征来辨认的。\n3. 音程 两个音之间的距离叫音程。我们简单一点按照音乐键盘来说明，可以看到下图键盘上为 12 个键一组，其中五个黑键七个白键。\n音度：其中每两个白键之间相差一度，一组白键为 CDEFGAB，从意式唱名上看就是 do/re/mi/fa/sol/la/ti。是七个基本音（或者叫自然音）之间的度量单位。从 C 到 C 就相差了八度。\n音数：每两个按键之间就是一个半音，中间隔一个按键就是全音。在这里所有按键都算，因此 CDEFGAB 七个音之间两两的音数就是，全全半全全全半。\n用以下一张表总结下\n   根音-\u0026gt;冠音 -\u0026gt; C -\u0026gt; D -\u0026gt; E -\u0026gt; F -\u0026gt; G -\u0026gt; A -\u0026gt; B -\u0026gt; C     C -\u0026gt; 一度\n0半音 二度\n2半音 三度\n4半音 四度\n5半音 五度\n7半音 六度\n9半音 七度\n11半音 八度\n12半音   D -\u0026gt;  一度\n0半音 二度\n2半音 三度\n3半音 四度\n5半音 五度\n7半音 六度\n9半音 七度\n11半音   E -\u0026gt;   一度\n0半音 二度\n1半音 三度\n3半音 四度\n5半音 五度\n7半音 六度\n9半音   F -\u0026gt;    一度\n0半音 二度\n2半音 三度\n4半音 四度\n6半音 五度\n7半音   G -\u0026gt;     一度\n0半音 二度\n2半音 三度\n4半音 四度\n5半音   A -\u0026gt;      一度\n0半音 二度\n2半音 三度\n3半音   B -\u0026gt;       一度\n0半音 二度\n1半音   C -\u0026gt;        一度\n0半音    3.1 一度和八度 一度是自己和自己的音，八度是自己和下一组自己的音。均为纯一度或纯八度。都是完全音程。以下均以 C 大调和弦为例。\n    C-\u0026gt;C D-\u0026gt;D E-\u0026gt;E F-\u0026gt;F G-\u0026gt;G A-\u0026gt;A B-\u0026gt;B     五度 纯五度 纯五度 纯五度 纯五度 纯五度 纯五度 减五度        C-\u0026gt;C8va D-\u0026gt;D8va E-\u0026gt;E8va F-\u0026gt;F8va G-\u0026gt;G8va A-\u0026gt;A8va B-\u0026gt;B8va     五度 纯五度 纯五度 纯五度 纯五度 纯五度 纯五度 减五度    3.2 大小二度 相邻的两个自然音为一个二度，但其音数不一定为 1，在 EF、BC 之间为半音。我们将有两个半音的二度称为大二度，只有一个半音的二度称为小二度。当然，小二度不等于半音。\n    C-\u0026gt;D D-\u0026gt;E E-\u0026gt;F F-\u0026gt;G G-\u0026gt;A A-\u0026gt;B B-\u0026gt;C     二度 大二度 大二度 小二度 大二度 大二度 大二度 小二度    3.3 大小三度 三度是由中间间隔一个音的两个自然音组成，我们将有四个半音的三度称为大三度，只有三个半音的称为小三度。\n    C-\u0026gt;E D-\u0026gt;F E-\u0026gt;G F-\u0026gt;A G-\u0026gt;B A-\u0026gt;C B-\u0026gt;D     三度 大三度 小三度 小三度 大三度 大三度 小三度 小三度    3.4 纯四度及增四度 四度由中间相隔两个按键的自然音组成。纯四度音由 5 个半音组成，而 F-\u0026gt;B 为六个半音，我们称之增四度，增四度为不协和音，听着会给人不安的感觉。\n    C-\u0026gt;F D-\u0026gt;G E-\u0026gt;A F-\u0026gt;B G-\u0026gt;C A-\u0026gt;D B-\u0026gt;E     四度 纯四度 纯四度 纯四度 增四度 纯四度 纯四度 纯四度    3.5 纯五度及减五度 五度音中间相隔三个按键的自然音组成。纯五度音由 7 个半音组成，而 B-\u0026gt;F 为六个半音，我们称之减五度，减五度也为不协和音，听着会给人不安的感觉。\n    C-\u0026gt;G D-\u0026gt;A E-\u0026gt;B F-\u0026gt;C G-\u0026gt;D A-\u0026gt;E B-\u0026gt;F     五度 纯五度 纯五度 纯五度 纯五度 纯五度 纯五度 减五度    3.6 大小六度和大小七度 同二三度，大六度为 9 个半音，小六度为 8 个半音，大七度为 11 个半音，小七度为 10 个半音。\n    C-\u0026gt;A D-\u0026gt;B E-\u0026gt;C F-\u0026gt;D G-\u0026gt;E A-\u0026gt;F B-\u0026gt;G     六度 大六度 大六度 小六度 大六度 大六度 小六度 小六度        C-\u0026gt;B D-\u0026gt;C E-\u0026gt;D F-\u0026gt;E G-\u0026gt;F A-\u0026gt;G B-\u0026gt;A     七度 大七度 小七度 小七度 大七度 小七度 小七度 小七度    3.7 音程总结 音程分为大音程、小音程、纯音程（完全音程）、增音程、减音程，当然还有倍增和倍减。\n方便的记忆就是：\n 音高距离叫音程，\n分为旋律与和声。\n一四五八无大小，\n二三六七没有纯。\n大纯增减即增减，\n小大相隔半音间。\n增减半音倍加前，\n一度要减不可能。\n二到八度C根记，\n大大纯纯大大纯。\n记时结合平均律，\n掌握规律记得深。\n ","date":1584237367,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1584237367,"objectID":"26da7d397b4f828cdadb58879d195f01","permalink":"https://blog.morningtzh.com/post/%E4%B9%90%E7%90%86/%E4%B9%90%E7%90%86%E7%AC%94%E8%AE%B01-%E9%9F%B3%E7%A8%8B.html","publishdate":"2020-03-15T09:56:07+08:00","relpermalink":"/post/%E4%B9%90%E7%90%86/%E4%B9%90%E7%90%86%E7%AC%94%E8%AE%B01-%E9%9F%B3%E7%A8%8B.html","section":"post","summary":"乐理笔记1\u0026ndash;音程 目录 1. 音 2. 泛音列与音色 3. 音程 3.1 一度和八度 3.2 大小二度 3.3 大小三度 3.4 纯四度及增四度 3.5 纯五度及减五度 3.6 大小六度和大小七度","tags":["乐理","音程","泛音列"],"title":"乐理笔记1--音程","type":"post"},{"authors":null,"categories":["职场"],"content":"创业公司经历 [TOC]\n在初创企业工作，是一件在职业道路中有正式规划的事情，也是一件意料之外的事情。没想到这段经历来的如此之快，但仔细一想这短短的经历几乎占据了我工龄的一半时间。\n在初创企业工作会面临比大厂更广泛的挑战。也能推动着学习更多的知识——大部分只会在自己成立公司时会用到，这些知识在符合个人发展需求时会飞快的融入到自身素养当中。\n独当一面的技术 在最初建立技术积累时会发现是完全从零开始的，得益于在原先公司业余时的技术积累，能快速理解，并选择当前状况下最好的技术方案。初创公司的基础决定了无法有健全的技术体系，需要根据业务做即时的调整，并且需要有前瞻性来保证做好了应对未来需求变化时不需要做较大的改动。每个新增功能尽量做增量型改动，这需要基本模块做到『低耦合高内聚』和『小而美』。\n研发人员需要对前沿技术有更多地了解，对不同技术领域的知识均有涉猎。虽然我是做 C 语言发开的，但是对前后端开发人员都能进行一些基本知识的指导，能讨论相应的技术解决方案。这个技能来源于用心学习，一个是自己做过相应技术的项目（无论是工作中或是业余项目），能 cover 住需求所需的技术要点即可；第二点是在实操中了解技术原理，从官方文档中去学习，反复推敲实现方案；第三点挺重要的，需要知道大家平时遇见的问题，并知道解决过程，即使是别人解决掉的问题也成为了自己的经验。\n最后被人的评价就是\u0026hellip;怎么什么都懂。当然啦，太多深入的技术知识我也能就不太了解了。\n管理知识 在我的观点中，进入初创公司，就需要把自己当成主人，如此才能获得更多经验来支撑未来的发展。在初创企业中，公司为了节约成本往往会将职能部门的hc预算放的很低（有时候技术部门都未免其难），行政、人力资源会招非专业的人员以降低成本。但企业实际的需求是需要更专业的人员来为企业量身制定规则，非专业人员无法有效的开展工作，会变成打杂人员。\n在这一矛盾下，企业实际管理者就需要有较高的素养了，对行政、管理、人力资源、财务等方面有一定的知识积累，才能带领公司发展。抛开预算和专业性的矛盾来说，如果管理者缺乏相关知识，即使招到了专家，也无法将其很好的利用起来。此处分两面说，当老板放权的情况下，专家缺乏对公司的了解，老板需要用一定的专业术语来描述公司状况，否则将会迎来很长的震荡阶段；另一方面老板不放权，那更需要通过一定的专业知识来指导专家做执行工作，否则可能导致南辕北辙。\n股权及一级市场投资 初创企业不可避免的会涉及到股权方面的问题，这是在初创企业打工所必备的知识，直接关系到劳动者的利益。这也是在进入初创企业时老板画的大饼。\n需要了解到的大致有：\n 注册资金 实缴和认缴 货币出资和非货币出资（技术入股） 股权转让方式 一级市场和二级市场 资本公积 股权溢价 公司类型（有限责任公司、合伙公司、股份公司） 合伙公司中的 GP、LP AB 股 破产清算 退出机制 VC/PE/FOF 股份变现方式和阶段 IPO（\u0026lt;\u0026ndash;太高级了，一点不懂）  这些知识了解后就会发现一些公司给出的股份可能有坑。例如公司在未实缴注册资金的情况下股权转让给员工，而后进行了天使轮投资，此时资方会要求所有股东实缴注册资金，那员工可能需要按比例出钱哦~\n这里面的门门道道太多了，以至于离职是老板面谈四五次用股份来挽留我也被我拒绝了。有空的时候可以将之前了解到的知识整理出来。\n管理者必备的素质 在工作过程中，体会到了创业如履薄冰，需要考究的事项太多。\n创始人的人格将会引导公司文化 首先要说明的是在和一些资方及高管交流的过程中，我们得出了一个结论：『创始人的人格会极大的影响公司文化』，这也应证了『小公司的发展看老板，中型公司发展看制度，大公司发展看文化』这句话。小公司的文化即老板个人人格的外显，会深刻的影响整个公司的发展。\n我们也曾私下讨论过一些问题，诸如当创始人能力不佳时资本方会逐渐加入管理，但是否能彻底将创始人边缘化的问题。对于这个问题我认为创始人在前期是无法被边缘化的，除了利益方面的问题，还有文化方面的。当创始人被边缘化后，消除其能力不佳对公司造成的影响的同时也会将公司的整个文化和所有的理念清洗掉，这将会从根本上泯灭一家公司的灵魂。\n因此创始人需要有一定的高度后创办一家公司的幸存率才会高。\n创始团队与社招 在公司经历一定发展后，将不满足于现有的规模，开始进行社招。初创团队往往会不舍得去招人，尤其在技术公司中，人员成本是公司开支的大头。当公司决定以低于市场价的标准招人，且没有其他吸引人的优势时就会引发一系列严重的问题。\n初创公司在招人方面往往有以下一些劣势：\n 工资没有吸引力 公司无行业影响力，甚至无人知晓 福利待遇低于相对成熟的公司 制度不完善 招聘方式不佳 招聘投入过低  这导致了初创公司只能在沙子中筛选金子，这个成本是巨大的，而且很难淘到金子，只会获得一团散沙。水向低处流，人往高处走，除非是一起参与公司创立的创始团队，很少会有精英选择加入一家短期收益低微，长期收益渺茫的初创公司。这也是创始团队和社招的区别所在。\n创始团队不易得，在我所经历的公司中，创始团队是创始人多次邀请邀请来的，其中的沟通成本是非常大的。创始团队的维持依托于后续公司良好的发展及获得长期收益的希望。经历过成熟企业和精英训练的创始团队拥有一定的见识和知识水平，能在一定程度上分辨公司的靠谱程度，以画饼招募到的创始团队无法以画饼维持，需要创始人通过务实的努力来维持创始团队的信心。\n社招不易得。创始团队可以通过创始人人格魅力来获得较高的性价比，但社招应聘人员往往考量的是实际获得的收入，在面试短短的一小时内，人格的吸引力还无法发挥作用。因此上文提到了获得创始团队的沟通成本是巨大的，这包含了展现人格魅力的时间。在实际收入较低时，便很难招到优秀的人，甚至很难找到优秀的应届生。同样在招到优秀的人才后如果降低人员流失率就是和创始团队一样的问题了。\n以上总总难处导致了初创企业人员配置不佳，\n信守承诺 完善流程制度 精细控制，对公司负责 信息控制 逻辑自洽 换位思考 员工情绪 ","date":1575369007,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1575369007,"objectID":"b6ce6b5b7bbe1bd80536b1669c7c2fe6","permalink":"https://blog.morningtzh.com/post/%E5%88%9B%E4%B8%9A%E5%85%AC%E5%8F%B8%E7%BB%8F%E5%8E%86.html","publishdate":"2019-12-03T18:30:07+08:00","relpermalink":"/post/%E5%88%9B%E4%B8%9A%E5%85%AC%E5%8F%B8%E7%BB%8F%E5%8E%86.html","section":"post","summary":"创业公司经历 [TOC] 在初创企业工作，是一件在职业道路中有正式规划的事情，也是一件意料之外的事情。没想到这段经历来的如此之快，但仔细一想这短短的经历","tags":["工作"],"title":"创业公司经历","type":"post"},{"authors":null,"categories":["深度学习"],"content":"线性回归及实现 [TOC]\n一年多前，《修真聊天群》更新看完了，在书荒引发的无聊情绪推动下学习了 Keras，用 LSTM 生成了大段无法看的《伪*修真聊天群》，没有耐心好好炼丹就没有再接触过深度学习的知识点，偶尔无聊看看聚宽上的文章也都是随机森林和隐马尔科夫模型等传统机器学习算法。 近期 gayhub 上榜了一个 《TensorFlow 2.0深度学习开源书》，正巧之后的新工作也与 TensorFlow 有些许关联，就趁机学习一下。\n看了教程打算手撸下公式推导及函数实现。（ \u0026lt;\u0026ndash; 抄袭狗 ）\n1.线性回归  线性回归是利用数理统计中回归分析，来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法，运用十分广泛。其表达形式为y = w\u0026rsquo;x+e，e为误差服从均值为0的正态分布。 \u0026mdash;- 百度百科\n 1.1 二元一次方程 当我们有个函数为 $y=wx+b$ 并且知道本函数穿过的两个点时我们可以轻易的算出函数中的常数$w$和$b$。\n假设有两点： $$ x_1=3,y_1=7 \\\nx_2=4,y_2=6 \\\n$$\n则其解为： $$ 7=3w+b \\\n6=4w+b \\\nw=-1,b=10 $$\n其曲线为：\nimport matplotlib.pyplot as plt plt.plot([3,4],[7,6]) plt.show() # show figure  1.2 观测误差 但是当我们的观测点存在误差时，公式变为了 $y=wx+b+\\epsilon,\\epsilon\\in\\mathcal{N}(\\mu,\\sigma^2)$. 此时我们无法用过之前的解法解出$w$和$b$的值。代码中采用random.random()-0.5模拟$\\epsilon$，我们会发现无论取哪两点去计算$w$和$b$都会导致函数存在巨大的偏离。我们只能通过回归分析去计算最佳的$w$和$b$。\nimport matplotlib.pyplot as plt import random x=range(0, 10) plt.plot(x,[-1*i+10+random.random()-0.5 for i in x], 'o') plt.plot(x,[-1*i+10 for i in x]) plt.show() # show figure  1.3 损失函数（loss） 此时我们引入了损失函数来计算$w$和$b$的好坏，在此例中采用均方误差(MSE)来评判： $$ \\mathscr{L}=\\frac{\\sum_{i=1}^{n}(wx_i+b-y_i)^2}n $$\n我们接下来的工作就是找到使$\\mathscr{L}$最小的$w$和$b$。\n1.4 梯度下降及优化函数 我们通过寻找$\\mathscr{L}$最小值来确定最佳的$w$和$b$，此时可通过求极值的方式来寻找损失函数的极小值。损失函数为三元方程，其偏导数即为梯度，我们用学习率(lr)来缩放梯度，通过不断的减去梯度来计算$w$和$b$，将其优化到最佳。 $$ w'=w-\\eta\\frac{\\partial \\mathscr{L}}{\\partial w} \\\nb'=b-\\eta\\frac{\\partial \\mathscr{L}}{\\partial b} \\\n\\eta\\text{为学习率 lr} $$\n解开偏导数以备后用： $$ \\begin{align} \\frac{\\partial \\mathscr{L}}{\\partial w} \u0026amp; = \\frac{\\partial \\frac{\\sum_{i=1}^{n}(wx_i+b-y_i)^2}n}{\\partial w} \\\n\u0026amp; = \\frac{2}{n}\\sum_{i=1}^{n} (wx_i+b-y_i)\\frac{\\partial (wx_i+b-y_i)}{\\partial w} \\\n\u0026amp; = \\frac{2}{n}\\sum_{i=1}^{n} (wx_i+b-y_i)x_i \\end{align} $$ $$ \\begin{align} \\frac{\\partial \\mathscr{L}}{\\partial b} \u0026amp; = \\frac{\\partial \\frac{\\sum_{i=1}^{n}(bx_i+b-y_i)^2}n}{\\partial b} \\\n\u0026amp; = \\frac{2}{n}\\sum_{i=1}^{n} (bx_i+b-y_i)\\frac{\\partial (bx_i+b-y_i)}{\\partial b} \\\n\u0026amp; = \\frac{2}{n}\\sum_{i=1}^{n} (bx_i+b-y_i) \\end{align} $$\n","date":1575165544,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1575165544,"objectID":"61ae28a7d2ab51bc0cef4328f71f647d","permalink":"https://blog.morningtzh.com/post/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%8F%8A%E5%AE%9E%E7%8E%B0.html","publishdate":"2019-12-01T09:59:04+08:00","relpermalink":"/post/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%8F%8A%E5%AE%9E%E7%8E%B0.html","section":"post","summary":"线性回归及实现 [TOC] 一年多前，《修真聊天群》更新看完了，在书荒引发的无聊情绪推动下学习了 Keras，用 LSTM 生成了大段无法看的《伪*修真聊天群》，没","tags":["回归"],"title":"线性回归及实现","type":"post"},{"authors":null,"categories":["技术"],"content":"我这么大个io_service去哪里了 [TOC]\n最近稍微闲了下来，开始debug Boost.Asio 析构时崩溃的问题。在目前代码中，使用到了deadline_timer作定时器。\n由于早期仅用简单的定时器，也就没多了解io_service的用法，简单地在每个短周期业务实例中各开了一组thread和io_service来挂deadline_timer。后来出现了一个问题，运行时发现在析构业务实例时delete io_service偶尔会崩溃（具体定位过程就不在这边展开了），就去看了源代码和reference。\n想着这么大的库api应该不会有太大的变化，点开boost最新版（1.71）reference，咦 O__O 我这么大个io_service去哪里了？\nLegend 1:Boost 1.71 Asio Reference 接下来从1.71版本往回翻，在1.66更新信息里发现一句话：  Implemented interface changes to reflect the Networking TS ( N4656).\n See the list of new interfaces and, where applicable, the corresponding old interfaces that have been superseded. The service template parameters, and the corresponding classes, are disabled by default. For example, instead of basic_socket we now have simply basic_socket. The old interface can be enabled by defining the BOOST_ASIO_ENABLE_OLD_SERVICES macro.   为了迎合C++ Networking TS的标准将接口改了，但是旧的接口依然还在支持。但一些service模板和相应的类默认不支持老版本，不过可以打开BOOST_ASIO_ENABLE_OLD_SERVICES宏来支持老版本service。\n以下仅列了一些我感兴趣的修改，完整版可以看上文的list链接。\n   New interface Old interface Notes      io_context  io_service The name io_service is retained as a typedef.    dispatch  io_service::dispatch The dispatch free function can be used to submit functions to any Executor or ExecutionContext.    post  io_service::post The dispatch free function can be used to submit functions to any Executor or ExecutionContext.    defer  io_service::post when the asio_handler_is_continuation hook returns true The defer free function can be used to submit functions to any Executor or ExecutionContext.    io_context::poll  io_service::poll overload that takes error_code\u0026amp; The error_code overload is not required.    io_context::poll_one  io_service::poll_one overload that takes error_code\u0026amp; The error_code overload is not required.    io_context::run  io_service::run overload that takes error_code\u0026amp; The error_code overload is not required.    io_context::run_one  io_service::run_one overload that takes error_code\u0026amp; The error_code overload is not required.    io_context::run_for, io_context::run_until, io_context::run_one_for, and io_context::run_one_until  These functions add the ability to run an io_context for a limited time.    io_context::restart  io_service::reset     execution_context, execution_context::service, and execution_context::id  io_service, io_service::service, and io_service::id The service-related functionality has been moved to the execution_context base class. This may also be used as a base for creating custom execution contexts.    make_service  add_service     strand  io_service::strand This template works with any valid executor, and is itself a valid executor.    executor_work_guard and make_work_guard  io_service::work Work tracking is now covered by the Executor requirements. These templates work with any valid executor.    Legend 2:Boost 1.71 Asio Interface Change List 在新接口表中我们可以看到`io_service`已经换成了`io_context`，且在1.66的[io_service](https://www.boost.org/doc/libs/1_66_0/doc/html/boost_asio/reference/io_service.html) reference中可以发现最上面就写了 ","date":1572400248,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1572400248,"objectID":"9310fe44067db2e29d1bc26ced1168bd","permalink":"https://blog.morningtzh.com/post/%E6%88%91%E8%BF%99%E4%B9%88%E5%A4%A7%E4%B8%AAio_service%E5%8E%BB%E5%93%AA%E9%87%8C%E4%BA%86.html","publishdate":"2019-10-30T09:50:48+08:00","relpermalink":"/post/%E6%88%91%E8%BF%99%E4%B9%88%E5%A4%A7%E4%B8%AAio_service%E5%8E%BB%E5%93%AA%E9%87%8C%E4%BA%86.html","section":"post","summary":"我这么大个io_service去哪里了 [TOC] 最近稍微闲了下来，开始debug Boost.Asio 析构时崩溃的问题。在目前代码中，使用到了deadline_time","tags":["C++"],"title":"我这么大个io_service去哪里了","type":"post"},{"authors":null,"categories":["coding"],"content":"boost.asio核心浅析 ","date":1572335450,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1572335450,"objectID":"d7d848b8bf47a68196fcc391a294dce9","permalink":"https://blog.morningtzh.com/post/boost.asio%E6%A0%B8%E5%BF%83%E6%B5%85%E6%9E%90.html","publishdate":"2019-10-29T15:50:50+08:00","relpermalink":"/post/boost.asio%E6%A0%B8%E5%BF%83%E6%B5%85%E6%9E%90.html","section":"post","summary":"boost.asio核心浅析","tags":["boost","c++"],"title":"boost.asio核心浅析","type":"post"},{"authors":null,"categories":["coding"],"content":"C++公共模块回调函数实现方式 在代码实现时，常常会遇到模块间函数调用的问题。对于一个公共模块，会有明确的public方法来作为接口，但是当需要发送消息（此处仅讨论回调函数）到外部业务模块的时候就很难去定义回调函数的类型。通常在命令式编程中会采用函数指针的方法，但在OO中调用者是一个类的话很难将类成员函数发给基础模块做回调函数。\n1. 传统函数指针回调 ","date":1567654807,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1567654807,"objectID":"ba62a6afd924612458b1b2fc9b1a3c2e","permalink":"https://blog.morningtzh.com/post/c++%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.html","publishdate":"2019-09-05T11:40:07+08:00","relpermalink":"/post/c++%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.html","section":"post","summary":"C++公共模块回调函数实现方式 在代码实现时，常常会遇到模块间函数调用的问题。对于一个公共模块，会有明确的public方法来作为接口，但是当需","tags":["c++","coding"],"title":"C++公共模块回调函数实现方式","type":"post"},{"authors":null,"categories":null,"content":"Git分支使用方法 分支概要 分支使用tip:\n 设三个分支, master/release/develop master和release 设置为只能管理员merge 可以把develop设置为默认分支 未来在网页端merge选上 Squash commits when merge request is accepted. merge到master分支上需要打上tag feature分支大家可自由创建~ 命名为 feature/xxx feature分支合并至develop时, 和以上一样选择. 最后次合入时同时选上 Delete source branch when merge request is accepted. 以删除feature分支  后续我会写一篇文档.\n参考文献  A successful Git branching model Git仓库分支(Branch)和标签(Tag)\n","date":1562321247,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1562321247,"objectID":"c0fc373e76997e3daa8f620dbc995683","permalink":"https://blog.morningtzh.com/post/git%E5%88%86%E6%94%AF%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.html","publishdate":"2019-07-05T10:07:27Z","relpermalink":"/post/git%E5%88%86%E6%94%AF%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.html","section":"post","summary":"Git分支使用方法 分支概要 分支使用tip: 设三个分支, master/release/develop master和release 设置为只能管理员merge 可以把develop设置为默认","tags":null,"title":"Git分支使用方法","type":"post"},{"authors":null,"categories":null,"content":"Windows 下 C++ 编程环境指导   Windows 下 C++ 编程环境指导   背景介绍  操作系统建议  Windows Subsystem for Linux  命令行环境参考   Windows   PowerShell 插件  Windows下命令行软件安装    Linux  命令行软件    C++ 代码规范   Google C++ Style Guide  Lint    编辑器指引   Clion配置   注册码  WSL连接  Google C++ Style Guide 配置    VSCode配置   强烈建议安装插件  建议安装插件:  可用Sync配置        背景介绍 最近安装了 Windows 系统，从来没有在 Windows 下面做过 Unix C++ 开发的我略有些懵逼（为什么在 windows 下开发是 Unix？因为我主要还是用 macOS 和 linux）。在经过一段时间的适应后，总结下Windows下开发的经验，供后续查看。\n操作系统建议 建议采用 Windows 10 作为工作的操作系统, 并安装WSL作为编译环境(详见下文).\n服务器使用 Ubuntu / CentOS / Manjaro.\n我个人服务器使用 Manjaro，这是一个滚动式更新的系统，是在Arch Linux基础上修改的更加易用的发行版。软件众多，同时社区维护的 aur 也支持直接从github上获取源代码编译安装。\nWindows Subsystem for Linux  Windows Subsystem for Linux（简称WSL）是一个为在Windows 10上能够原生运行Linux二进制可执行文件（ELF格式）的兼容层。它是由微软与Canonical公司合作开发，目标是使纯正的 Ubuntu 映像能下载和解压到用户的本地计算机，并且映像内的工具和实用工具能在此子系统上原生运行。\n安装指引请查看Microsoft官网: Linux 安装指南适用于 Windows 10 的 Windows 子系统\n后续 WSL2 发行后，本段再做修改。考虑到 WSL 和 WSL2 是不冲突的两种功能，届时再看使用哪一种。\n命令行环境参考 Windows 主要采用PowerShell, 详情参考 PowerShell官网.\nPowerShell 插件 PowerShell插件主要位于 PowerShell Gallery, 可安装oh-my-posh, posh-git等插件\nWindows下命令行软件安装 Windows下包管理器主要采用 Choco, 可像Linux下包管理器一样使用.\nLinux Linux 下命令行建议采用 zsh, 并加装 Oh-my-zsh. （WSL自然也包括在其中）\n以下为安利贴: 为什么说 zsh 是 shell 中的极品？\n命令行软件 Windows下命令行软件建议采用 FluentTerminal, 使用Choco安装 choco install fluent-terminal. 在设置中可选择WSL/PowerShell/CMD 作为默认命令行, 建议采用WSL.\nC++ 代码规范 Google C++ Style Guide C++代码规范目前采用 Google C++ Style Guide 也可参考 此中文版教程.\n后续会有微调, 将会详细写出.\nLint Lint采用 Clang-tidy做静态分析, 目前项目根目录有clang-tidy.py 文件来做批量Lint. 可采用命令行 ./clang-tidy.py -checks \u0026quot;google-*\u0026quot; -fix -p ./build ./src/* 做检查.\n编辑器指引 编辑器采用 Clion作为C++开发编辑器, Visual Studio Code 作为辅助编辑器使用.\nClion配置 注册码 Clion注册码可以去淘宝购买，2018-02版本后授权服务器已失效。\nWSL连接 请参考Clion官方文档: How to use wsl development environment in clion\nGoogle C++ Style Guide 配置 请参考Clion官方文档: Code Style. C/C++ #Set From\n在Set From 中选择 Google.\nVSCode配置 强烈建议安装插件  配置同步  settings sync   Git相关  gitblame githistory gitlens   C++相关  cmake cmake-tools cpptools include-autocomplete   Markdown及UML相关  markdown-all-in-one markdown-preview-enhanced plantuml vscode-markdownlint   方便编辑  beautify indent-rainbow output-colorizer path-intellisense rainbow-csv    建议安装插件: 可能有点多\u0026hellip;可自行筛选, 覆盖了一些常用语言\n auto-close-tag\rauto-rename-tag\rbackground\rbeautify\rbetter-toml\rbracket-pair-colorizer\rchange-case\rcmake\rcmake-tools\rcode-runner\rcode-settings-sync\rcode-spell-checker\rcopilot-vscode\rcpptools\rgc-excelviewer\rgitblame\rgithistory\rgitlens\rGo\rinclude-autocomplete\rindent-rainbow\riris\rJavaScriptSnippets\rmarkdown-all-in-one\rmarkdown-pdf\rmarkdown-preview-enhanced\rmssql\rnbpreviewer\rnodejs-docs\routput-colorizer\rpath-intellisense\rplantuml\rpowershell\rpyqt-integration\rpython\rquicktype\rrainbow-csv\rreact-native-react-redux\rrest-client\rtheme-dracula\rtslint\rvs-color-picker\rvscode-babel-coloring\rvscode-clang\rvscode-database\rvscode-eslint\rvscode-filesize\rvscode-hexdump\rvscode-hexo\rvscode-import-cost\rvscode-insertdatestring\rvscode-language-babel\rvscode-language-pack-zh-hans\rvscode-leetcode\rvscode-markdownlint\rvscode-mysql\rvscode-power-mode\rvscode-qt-for-python\rvscode-styled-components\rvscode-svgviewer\rvscode-text-pastry\rvscode-yaml\rwebpack\r 可用Sync配置 首先安装settings sync插件, 选择同步公开gist: 7b4026c4de4f3170fb1770945dbdf52e\n","date":1558367529,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1558367529,"objectID":"39f10a5c4dbc8ef608fc0d5b2167e6a1","permalink":"https://blog.morningtzh.com/post/windows%E4%B8%8B-c++-%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83.html","publishdate":"2019-05-20T15:52:09Z","relpermalink":"/post/windows%E4%B8%8B-c++-%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83.html","section":"post","summary":"Windows 下 C++ 编程环境指导 Windows 下 C++ 编程环境指导 背景介绍 操作系统建议 Windows Subsystem for Linux 命令行环境参考 Windows PowerShell 插件 Windows下命令行软件安装 Linux 命令行软件 C++ 代码规范 Google","tags":null,"title":"Windows 下 C++ 编程环境","type":"post"},{"authors":null,"categories":null,"content":"博客系统的需求在哪里 半年前，有了更多对前端的思考便打算将自研博客系统落地。这个想法由来已久，从大学时期的 wordpress、dokuwiki到\u0008毕业后搭建的 hexo 静态博客，折腾了系统、捣鼓了插件，最终写的文章寥寥，后来也兴致缺缺。渐渐就期望有一个亲手建立的博客系统，\u0008删减复杂的功能，保留最精要的功能即可。\n差不多花了一个月时间\u0008写出了博客主要的功能，采用了 Twitter 的页面风格，前端架构主要使用 react + mobx + antd，后端使用 flask。\u0008Feature 包括了人脸识别登陆、markdown在线编辑、moment 和博客差异化显示、支持 hashtag 等等。\n闲来也写了点东西，功能确实精简也舒适，无需手动登录，允许网页使用摄像头就能开始在任何地方写作了。但慢慢发现使用起来又回到了最初的问题，似乎又懒得写作了。画图需要先画，再截图，然后上传到七牛，最后把地址丢在\u0008文章中，图片一多（人）就崩溃了，即使用了一些手段图片自动上传七牛，流程依然复杂。\u0008即使后面做下去我做到最好也就是现有博客系统的层次，对我来说依然是鸡肋的。\n最近想了想，无论是 wp、hexo 还是自研博客说到底是工具不称手了，没有系统化的思考过写作到底是什么，用发布工具来当做写作平台，自然有些南橘北枳的感觉。遵循接口设计的一系列原则，我们应该将模块\u0008功能做到尽可能单一、对外暴露尽可能小，就这两点去思考之前的写作流程，便会发现我做错了，博客网站功能依然太多了，需要再进行功能的划分。\n我们首先将写作一整个流程进行拆分：\n 灵感 腹稿 \u0008大纲(暂时我随性写) 写作 发布  之前的错误在于混淆了写作与发布流程，糅杂在了一起。虽然在线的富文本编辑器非常好用，方便做排版之类的工作，但是终究是功能不完善的，而且不能做到本地软件这样的方便。\n考虑了半天，还是写作和发布分离吧，其中最复杂的地方可能是所见即所得，因此要求网页后台 markdown 渲染和编辑器 markdown 采用同一套渲染方案。这样再编辑器上写的东西就能保证和网页上显示的一样了。\n这部分找了些资料，例如 marked、highlight、simplemde等前端 md 渲染或是富文本编辑器，似乎效果都会有出入。最终准备从 vscode 入手，发现 markdown preview exhance 的作者有在 github 开源其插件，从插件的代码中不难找到他使用的 markdown 渲染方式。\n最终在其另一个开源项目『 mume』中找到了解决方案，其调用非常简单，在 vscode 中的插件配置项几乎源于这一项目的配置。在做新的博客页面时直接用mume渲染即可~ 当然这样就相当于是另外做一套静态网页了。（这个想法倒是可以和原作者交流呢~ hhh）\n新博客系统其实并不类似静态网页，依然会有前后端交互，只是将文章部分的渲染交给了后端的mume，前端的 marked 渲染依旧会继续使用，用于渲染出摘要。\n这样的新设计，抛弃了\u0008原有的一堆功能，在新方案中，将会有四个成员来完成一整套博客系统：\n 撰写工具：vscode+mpe 发布工具：nodejs+mume 将和mpe 使用同一份配置，保证所见即所得 后端：仅用于读取数据库 前端：依然采用之前的展示方式，删去渲染部分  这样的方案，写作流程就会变得更简单，对于 markdown 来说比较麻烦的图床也可以通过 mpe 中的图片管理来解决。\n","date":1539346997,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1539346997,"objectID":"7841dfdebde1f662e24a466bf286fd41","permalink":"https://blog.morningtzh.com/post/%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%9C%80%E6%B1%82%E5%9C%A8%E5%93%AA%E9%87%8C.html","publishdate":"2018-10-12T12:23:17Z","relpermalink":"/post/%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%9C%80%E6%B1%82%E5%9C%A8%E5%93%AA%E9%87%8C.html","section":"post","summary":"博客系统的需求在哪里 半年前，有了更多对前端的思考便打算将自研博客系统落地。这个想法由来已久，从大学时期的 wordpress、dokuwiki","tags":null,"title":"博客系统的需求在哪里","type":"post"},{"authors":null,"categories":["coding"],"content":"devstack安装镜像 pip镜像： pip 镜像我使用清华大学的，在可信列表（ 豆瓣的可坑死啦，不在信任列表，安装会跳问题：豆瓣源『http://pypi.douban.com/simple』）\n In file \u0026ldquo;~/.pip/pip.conf\u0026rdquo;\n  [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple\n Ubuntu Apt 镜像 apt镜像反正看你喜欢咯！！！\n In file \u0026ldquo;/etc/apt/sources.list\u0026rdquo;\n    openstack@openstack deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe m ultiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe mu ltiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe m ultiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiv erse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted univer se multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted univers e multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted univer se multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted unive rse multiverse\n ## openstack git 镜像 In file ?/local.conf (官网并没说丢在哪里。。。我就 devstack 文件夹和用户主目录都丢了个)  [[local|localrc]] ADMIN_PASSWORD=openstack DATABASE_PASSWORD=$ADMIN_PASSWORD RABBIT_PASSWORD=$ADMIN_PASSWORD SERVICE_PASSWORD=$ADMIN_PASSWORD\n# Define images to be automatically downloaded during the DevStack built process. DOWNLOAD_DEFAULT_IMAGES=False IMAGE_URLS=\u0026ldquo;http://download.cirros-cloud.net/0.3.4/cirros-0.3.4-x86_64-disk.img\u0026quot;\n#change github to trystack GIT_BASE=${GIT_BASE:-http://git.trystack.cn} NOVNC_REPO=${NOVNC_REPO:-http://git.trystack.cn/kanaka/noVNC.git}\n 这个镜像下载速度我家 20M 水管，下载速度为600+kiB/s ## 小问题 pypi 包更新的时候（~/devstack/file/get-pip.py文件）很容易断，我直接手机[GoodReader](https://itunes.apple.com/us/app/goodreader/id777310222?mt=8)下载好后，再电脑用 GoodReader 上的地址下的，速度很快。 虚拟机内存1G 不够！！！会报错！！！ 哇靠。。。我电脑反正玩不来了，虚拟机给了2g 交换空间1g 全部占满，难怪听说要4g 内存。我还是光看看代码吧 其他的安装就按 devstack 官网就行了  ","date":1474399814,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1474399814,"objectID":"743beb1fb0ab90a6cd6653c9ba4c2d7b","permalink":"https://blog.morningtzh.com/post/devstack-install-tips.html","publishdate":"2016-09-20T19:30:14Z","relpermalink":"/post/devstack-install-tips.html","section":"post","summary":"devstack安装镜像 pip镜像： pip 镜像我使用清华大学的，在可信列表（ 豆瓣的可坑死啦，不在信任列表，安装会跳问题：豆瓣源『http://p","tags":["python","openstack"],"title":"devstack安装镜像","type":"post"},{"authors":null,"categories":["coding"],"content":"阿婆主脑容量不够，ぜんぜん不能在大脑中运行 Brainfuck 程序，而且发现连运行过程都想不出来啊， 然而就这么几个字符完全可以自己写解释器嘛，并且可以打印出运行过程，而且可以试试看做成playground 的形式呢，想想还是挺有趣的。\n项目地址： Code CSDN\nGit地址： Git on CSDN\nBrainfuck Brainfuck是一种图灵完备的语言，他可以做到任何事情，他的编译器是世界上最小的，他共有8个操作符：\n   Operator Function     \u0026gt; increment the data pointer (to point to the next cell to the right).   \u0026lt; decrement the data pointer (to point to the next cell to the left).   + increment (increase by one) the byte at the data pointer.   - decrement (decrease by one) the byte at the data pointer.   . output the byte at the data pointer.   , accept one byte of input, storing its value in the byte at the data pointer.   [ if the byte at the data pointer is zero, then instead of moving the instruction pointer forward to the next command, jump it forward to the command after the matching ] command.   ] if the byte at the data pointer is nonzero, then instead of moving the instruction pointer forward to the next command, jump it back to the command after the matching [ command.    基本就是对内存直接操作的语言，他的『Hello World!』是这样的：\n \u0026ldquo;++++++++[\u0026gt;++++[\u0026gt;++\u0026gt;+++\u0026gt;+++\u0026gt;+\u0026laquo;\u0026laquo;-]\u0026gt;+\u0026gt;+\u0026gt;-\u0026raquo;+[\u0026lt;]\u0026lt;-]\u0026raquo;.\u0026gt;\u0026mdash;.+++++++..+++.\u0026raquo;.\u0026lt;-.\u0026lt;.+++.\u0026mdash;\u0026mdash;.\u0026mdash;\u0026mdash;\u0026ndash;.\u0026raquo;+.\u0026gt;++.\u0026rdquo;\n WTF!!!!!!\n需求点   1、基本功能\n 解释裸BF程序 打印内存信息 分开输出以及集体输出    2、调试功能\n 设置断点 单步执行 查看内存    3、playground功能\n 做命令行模式（加参数可选） 窗口分割 实时解释    基本功能实现 Brainfuck基本解释使用class BF()来实现\n数据部分 class BF()中数据由两部分组成：\n Brainfuck程序 内存  BF直接对内存进行操作，所以这边可以很简单的用list模拟出来，这样我们就有了一个无限长的内存，并用BF.position来指明正在操作的内存，相当于一个指针（实际是list index）。另外一个就是代码存储区，代码由string类型的BF.code保存，同样有个代码指针BF.codePosition指明目前正在解释的操作符.\ndef __init__(self): self.codeInit() self.ifRuntime = True def memoryInit(self): self.dirty = False # if memory have been wroten self.memory = [0] # memory self.position = 0 # pointer to memory which byte now operating self.codePosition = 0 # pointer to code which operator now parsing self.result = '' # store whole program output def codeInit(self, code = None): if None == code: # for object init without BF code self.code = '' self.code = code self.memoryInit()  操作符动作 操作符没有一点难度,按照wiki来解释。\ndef getChar(self): return self.memory[self.position] '''operators''' def printChar(self): print \u0026quot;echo: \u0026quot;, print chr(self.memory[self.position]) # turn to ASCII char self.result += chr(self.memory[self.position]) # store output def inputChar(self): print \u0026quot;put in: \u0026quot;, self.memory[self.position] = ord(sys.stdin.read(1)) def increment(self): self.memory[self.position] += 1 def decrement(self): self.memory[self.position] -= 1 def next(self): self.position += 1 if len(self.memory) \u0026lt;= self.position: self.memory.append(0) def previous(self): self.position -= 1 if 0 \u0026gt; self.position: print 'error: position is %d'%self.position print printMemory()  循环实现 循环实现比较麻烦，本来只简单地想到一对括号的情况，后面发现了多对括号的问题，就先使用direction来保存括号在代码中的位子。并且用stack来先记录左括号。\n首先在loopParser()中记录成对的括号位置，同时意味着循环开始结束地址也被记录了下来。在这个函数中，首先使用stack来登记未配对左括号地址，并在出现右括号时，弹出一个左括号地址，与右括号地址配对，写入loopMap这个direction**中，同样这个地址配对记录需要返回给主解析流程的。\n在主流程中，通过loopParser()获得loopMap后,就开始对整个BF代码进行解释。此时根据wiki中的操作符作用，遇到**[**时检查当前指针内容是否为0，为0则不进入循环，直接跳到对应的**]**地址上，遇到**]**时，当前指针内容不为0，则跳回到对应**[**代码地址，继续循环。\ndef loopParser(self, code): '''parse loop operator, recode the position of code''' loopMap = {} leftStack = [] codePosition = 0 leftNum = 0 rightNum = 0 for operator in code: if operator == '[': leftStack.append(codePosition) leftNum += 1 elif operator == ']': leftPosition = leftStack.pop() rightPosition = codePosition loopMap[leftPosition] = rightPosition loopMap[rightPosition] = leftPosition rightNum += 1 codePosition += 1 if 0 != len(leftStack): print \u0026quot;error: there are %d '[' but %d ']'\u0026quot; loopMap = None return loopMap def parser(self, code = None): '''parse code''' if None == code: code = self.code self.memoryInit() loopMap = self.loopParser(code) if None == loopMap: return if None == code: code = self.code while self.codePosition \u0026lt; len(code): operator = code[self.codePosition] if operator == \u0026quot;\u0026gt;\u0026quot;: self.next() elif operator == \u0026quot;\u0026lt;\u0026quot;: self.previous() elif operator == \u0026quot;+\u0026quot;: self.increment() elif operator == \u0026quot;-\u0026quot;: self.decrement() elif operator == \u0026quot;.\u0026quot;: self.printChar() elif operator == \u0026quot;,\u0026quot;: self.inputChar() elif operator == \u0026quot;[\u0026quot; and self.getChar() == 0: self.codePosition = loopMap[self.codePosition] elif operator == \u0026quot;]\u0026quot; and self.getChar() != 0: self.codePosition = loopMap[self.codePosition] self.runtime() self.codePosition += 1  打印runtime 做这个解释器的主要原因就是，看不懂Brainfuck每一步为什么要这样做，所以解释器的重点就在于打印每一步的数据内存和代码内存，并且标出目前运行到哪里了。\nGlobal function: def printChar(char, point = False): if point: char = '\\033[31m%s\\033[0m' %char # print red chars on Unix sys.stdout.write(char + ' ') BF() method: def printData(self, data, position): '''print linear data and point the position now point''' point = False for nowPosition in xrange(0, len(data)): if nowPosition == position: point = True printChar(str(data[nowPosition]), point) point = False print \u0026quot;\u0026quot; # printChar don't print '\\n' def runtime(self): '''print runtime memory and code''' if self.ifRuntime: self.printData(self.code, self.codePosition) self.printData(self.memory, self.position)  基本功能运行结果 未完待续。。。或者。。。\n","date":1449351794,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1449351794,"objectID":"6a093891879fc5983aba2bee428fd601","permalink":"https://blog.morningtzh.com/post/brainfuck-interpreter.html","publishdate":"2015-12-05T21:43:14Z","relpermalink":"/post/brainfuck-interpreter.html","section":"post","summary":"阿婆主脑容量不够，ぜんぜん不能在大脑中运行 Brainfuck 程序，而且发现连运行过程都想不出来啊， 然而就这么几个字符完全可以自己写解释器嘛，并且可以打印出运行过程，而且可以试试看做成playground 的形式呢，想想还是挺有趣的。\n","tags":["python","Brainfuck"],"title":"Brainfuck解释器[on python]","type":"post"},{"authors":null,"categories":["coding"],"content":" 最近因为在学Haskell，所以需要在电脑上安装GHC，然而遇到了一些困难，所以需要做一下记录。\n##安装GHC## 首先GHC安装，其实这并不需要从brew安装的，我们可以从 官网找到OSX的app，下载就好.当然上面很坑爹的写了一句：\n Requirements\nOnly tested on 64-bit Mac OS X 10.10\n 好吧好吧，这个免责协议我认。。。\n下载下来就按照官网上的提示安装就好，拖到 /Application\u0026hellip;\n  Download and unzip ghc-7.10.2-r0.zip (193MB) Move it to a stable location such as /Applications Double-click for instructions to install Xcode and add it to your Terminal\u0026rsquo;s $PATH   第一个坑爹的来了，app会说建立 ~/.zshenv 并将环境变量脚本自动拷贝进去，然而在实际使用中似乎 ~/.zshenv 并没有在使用，我并不是很了解zsh还有这个文件，并且实际操作无效，所以我还是将它放进了 ~/.zshrc 中，当然是有效的。\n##使用cabal## 在El Capitan中使用\n ➜ Haskell git:(master) ✗ cabal install cabal-install\ncabal: /usr/bin/ar: permission denied\n 会发现 权限不够！！！！ WTF\n好吧。。。找了半天。好吧我找的有错误。。。在 Stack Overflow中找 [haskell]el capitan 才能完美的找到解决方案！！！（好吧，其实我也知道是El Capitan的Rootless模式，只是在寻找其他解决方案而已） 在 Haskell for Mac (El Capitan)中指出，需要关闭 Rootless ：\n 重启，使用 CMD+R 进入recover模式\n在终端中输入 csrutil disable 关闭Rootless模式，并重启\n 这样再使用cabal install就不会有权限问题了~\n当然El Capitan的Rootless是新开发的强有力对抗入侵的方式，Rootless使能后，即使root用户也无权对核心文件进行修改和执行。\n","date":1449351794,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1449351794,"objectID":"555a1df9ddca26a5909905ad920172a8","permalink":"https://blog.morningtzh.com/post/install-ghc-on-mac.html","publishdate":"2015-12-05T21:43:14Z","relpermalink":"/post/install-ghc-on-mac.html","section":"post","summary":" 最近因为在学Haskell，所以需要在电脑上安装GHC，然而遇到了一些困难，所以需要做一下记录。\n","tags":["haskell","cabal","El Capitan"],"title":"Install GHC on El Capitan","type":"post"},{"authors":null,"categories":["coding"],"content":"LYAH字典查询函数理解指南 for what 最近在看Haskell，并且极度想要给好基友安利这一个语言。So，今天看 《Learn You a Haskell for Great Good》恰巧基友被我安利烦了，问我haskell有什么好的，我刚看到§7.4 Data.Map这章，就发了看到的第一个函数给他，不过感觉他会看不懂，就想写个讲解给他，写长了之后就想成文了。\n那个函数 这是一个从字典中找值的函数\n findKey :: (Eq k) =\u0026gt; k -\u0026gt; [(k,v)] -\u0026gt; v\nfindKey key xs = snd . head . filter (\\(k,v) -\u0026gt; key == k) $ xs\n 举个栗子 这个例子同样是从LYAH中搞出来的：\n phoneBook = [(\u0026ldquo;betty\u0026rdquo;,\u0026ldquo;555-2938\u0026rdquo;) , (\u0026ldquo;bonnie\u0026rdquo;,\u0026ldquo;452-2928\u0026rdquo;) , (\u0026ldquo;patsy\u0026rdquo;,\u0026ldquo;493-2928\u0026rdquo;) ,\n(\u0026ldquo;lucille\u0026rdquo;,\u0026ldquo;205-2928\u0026rdquo;) ,\n(\u0026ldquo;wendy\u0026rdquo;,\u0026ldquo;939-8282\u0026rdquo;) ,\n(\u0026ldquo;penny\u0026rdquo;,\u0026ldquo;853-2492\u0026rdquo;) ]\n 函数申明  findKey :: (Eq k) =\u0026gt; k -\u0026gt; [(k,v)] -\u0026gt; v\n 在函数中，首先第一行是函数申明，他和其他语言一样表明了输入输出。\n在haskell中函数仅支持一个返回值，支持多个入参。在上面的申明中 findKey 是函数名，以 \u0026ldquo;::\u0026ldquo;来标明函数，后面一共有四个东西，\n (Eq k) =\u0026gt; k -\u0026gt; [(k,v)] -\u0026gt; v\n 首先可以仅理解后三个：\n k -\u0026gt; [(k,v)] -\u0026gt; v\n 这是函数参数和返回值，这个函数中一共有两个参数和一个返回值，函数申明中的最后一个箭头\u0026rdquo;-\u0026gt;\u0026ldquo;是一定指向返回值的，当然\u0026rdquo;k v\u0026ldquo;这两个字母一定会让人觉得很疑惑，在haskell中函数声明中的字母其实只代表一个变量类型哦 sorry，haskell中没有变量，他只有常量，所有都是静态参数，所以这个字母代表了一种模糊的参数类型，这仅表示上面两个k需要是同样的类型，而两个v也需要是同样的类型，随便用abcd也可以。所以：\n \u0026ldquo;k\u0026rdquo; \u0026ldquo;[(k,v)]\u0026rdquo; 是两个入参，第一个参数是k类型的参数，第二个参数是一个list，list中是一个有两个类型为k v为成员的tuple\n\u0026ldquo;v\u0026rdquo; 是函数的返回值，它的类型需要和入参list中tuple第二个元素一样。\n 然后我们来说一说\u0026rdquo;(Eq k) =\u0026gt;\u0026rdquo;, \u0026ldquo;=\u0026gt;\u0026ldquo;是对后面参数的约束条件，\u0026quot;(Eq k)\u0026ldquo;说明后面的 \u0026ldquo;k\u0026rdquo; 类型的参数必须是一个Eq的派生类型，这种类型是可以比较的，比如int，char。\n在事例中我们可以按照\n findKey \u0026ldquo;betty\u0026rdquo; phoneBook\n 的方式进行调用，其中phoneBook可扩展成的[(\u0026ldquo;betty\u0026rdquo;,\u0026ldquo;555-2938\u0026rdquo;)\u0026hellip;]，看起来形式就差不多了。\n函数实体 函数调用  findKey key xs = snd . head . filter (\\(k,v) -\u0026gt; key == k) $ xs\n 这是函数体，在等号左边的是函数调用的方式，在这个函数中，调用方式是：\n findKey key xs\nexample:findKey \u0026ldquo;betty\u0026rdquo; phoneBook\n 当然也可以是中序，这个就另讲了。这个函数调用方式也是一种模式匹配，这边的\u0026rdquo;key\u0026quot;、\u0026quot;xs\u0026ldquo;匹配了函数的两个入参\u0026rdquo;k\u0026quot;、\u0026quot;[(k,v)]\u0026rdquo;\nfilter 接下来对这两个入参进行操作(先忽略\u0026rdquo;$\u0026ldquo;符号)：\n filter (\\(k,v) -\u0026gt; key == k) xs\n 首先是filter，这个是对一个list的过滤器，是\u0026rdquo;filter f list\u0026quot; 这样的模式，对list的每一个元素使用函数f进行匹配。在此例中\n (\\(k,v) -\u0026gt; key == k)\n 就是filter中的 f ，haskell中使用 \\做lambda，lambda就是一个隐式函数。\n在lambda中\u0026quot;-\u0026gt;\u0026ldquo;是用来区分参数和lambda函数本体的，在\u0026rdquo;-\u0026gt;\u0026ldquo;左边是函数参数，可做模式匹配。在此lambda函数中，用\u0026rdquo;(k,v)\u0026ldquo;来匹配list成员tuple的成员。第一个\u0026rdquo;(k,v)\u0026ldquo;就是：\n (\u0026ldquo;betty\u0026rdquo;,\u0026ldquo;555-2938\u0026rdquo;)\n 此lambda用来匹配 xs 这个list取出来的每一个元组，并且判断此元组中的键值 k 是否能匹配入参的 key。并且filter会将符合条件的元素==重新组合==成一个新的list，在此例中，filter结果就是\n [(\u0026ldquo;betty\u0026rdquo;,\u0026ldquo;555-2938\u0026rdquo;)]\n 后面键值不为***\u0026ldquo;betty\u0026rdquo;***的元组就会被舍弃，这是仅有一个元素的list。\nsnd head 接下来这个是head，这个函数用来取list的头部，取出来就是第一个元素，例如\n ***head [3,2,5,3,6,3,4,3,7]***的结果就是3\n 在此例中结果大致是：\n (\u0026ldquo;betty\u0026rdquo;,\u0026ldquo;555-2938\u0026rdquo;)\n 是的，你会发现，这仅仅是去掉了中括号，这代表着这不再是一个list了。\n接下来snd用来取tuple中的第二个元素，就是字典中的value，也就是\n \u0026ldquo;555-2938\u0026rdquo;\n 就能得出函数返回值了。这边需要注意的是，snd的参数只能是二元tuple。\n函数组合 snd . head . filter 这个是函数组合，相当于一下子调用了三个函数。这个可以用数学公式来表示：\n (f.g)(x) = f(g(x))\n 在此处\n snd.head.filter f $ list = snd(head(filter f list)))\n 在haskell中，函数组合是一个让代码简洁明了的手段，但是他也有它的局限性，就是说他的参数只能唯一，函数组合仅能包含一个参数。但是此处柯里化使得组合函数使用多参成为可能。\n柯里化（Currying） 柯里化是现代化语言中包含的一个非常有趣的特性之一，在js、swift中也支持柯里化（非常遗憾swift仅在Language Reference中提到了一点）。\nCurrying是指函数可以不完全调用，他可以将多参函数转化为单参函数来求解。例如\u0026rdquo;+\u0026ldquo;函数（对，在haskell中\u0026rdquo;+\u0026ldquo;也是一个函数）\n 5+4 =======\u0026gt; 9\n 其可以转化为：\n let plusFive = (+5)\n 这样一来我们就多了一个新的函数叫做plusFive，我们来调用它：\n plusFive 4 =======\u0026gt; 9\nplusFive 167 =======\u0026gt; 172\n ok，Currying就是这样一个好玩的特性，我自己认为，这个和惰性有关，因为Curried Function切切实实要在有完整入参时才会调用。\n对于本例来说，我们将\n filter (\\(k,v) -\u0026gt; key == k) xs Currying成 (filter (\\(k,v) -\u0026gt; key == k)) xs\n 在组合函数中其实是组合成了\n (snd . head . filter (\\(k,v) -\u0026gt; key == k)) xs\n 在原函数中，少了\u0026rdquo;()\u0026quot;,多了\u0026quot;$\u0026quot;:\n snd . head . filter (\\(k,v) -\u0026gt; key == k) $ xs\n 这边用到了的\u0026quot;$\u0026quot;,如果缺少\u0026quot;$\u0026quot;\n snd . head . filter (\\(k,v) -\u0026gt; key == k) xs 会被理解成\nsnd . head . (filter (\\(k,v) -\u0026gt; key == k) xs)\n 而这绝对是会被编译器理解不能的句子，会报错，\u0026quot;$\u0026ldquo;改变了filter函数的匹配方式，在haskell中\u0026rdquo;$\u0026ldquo;是拥有最低优先级的函数调用符，相当于一个函数，所以会变成\n snd . head . filter (\\(k,v) -\u0026gt; key == k) ($ xs)\n 函数组合的优先级大于***$ xs***的优先级，就会前面线组合起来。\u0026quot;**$**\u0026ldquo;是一个非常节约括号的函数调用符.\n函数结论  findKey \u0026ldquo;betty\u0026rdquo; phoneBook\n\u0026ldquo;555-2938\u0026rdquo;\nfindKey \u0026ldquo;patsy\u0026rdquo; phoneBook\n\u0026ldquo;493-2928\u0026rdquo;\n 就此结束吧，心血来潮谢谢，先打上个标签1，说不定还有2，3，4\u0026hellip;呢，也或许会太监了呢。\n","date":1446909755,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1446909755,"objectID":"763f948e0af7b0fd505d2cc19b9c2286","permalink":"https://blog.morningtzh.com/post/about-haskell-1.html","publishdate":"2015-11-07T23:22:35+08:00","relpermalink":"/post/about-haskell-1.html","section":"post","summary":"LYAH字典查询函数理解指南 for what 最近在看Haskell，并且极度想要给好基友安利这一个语言。So，今天看 《Learn You a Haskell for Great Good》恰巧基友被我安利烦了，问我haskell有什么好的，我刚看到§7.4 Data.Map这章，就发了看到的第一个函数给他，不过感觉他会看不懂，就想写个讲解给他，写长了之后就想成文了。\n","tags":["haskell","currying","functional programming"],"title":"关于haskell随便写点什么1","type":"post"},{"authors":null,"categories":["wine"],"content":"三得利老牌快喝完了，打算醒一段时间再尝一下变化，正好家里有一套百龄坛特醇礼盒，就开了喝。\n特醇刚入口，感觉和老牌没什么区别啊，没有像格兰菲迪那样和老牌有明显的区别。特醇显得有些辣了。特意倒了些老牌做了下比较。\n三得利老牌更加顺口，因此感觉香气更加浓郁。百龄坛比较刺激，香气也少了些，也确实有区别的。两者对比格兰菲迪的话，差别很大，格兰菲迪入口有一种麦芽的味道？会留存很久。\n老牌和百龄坛特醇都比较醇吧，特醇的评分我记得也特别高呢，而且价格便宜，某宝也只要半百就够，比约翰走路红牌更加便宜。老牌后味有巧克力奶油的味道，说实话，喝老牌的第一口我就开始怀念百利甜了，老牌的奶油味重，这一点特醇略差了点。\n刚刚开始入门whisky，能感受到的差别挺小的，期待整瓶的单一麦芽能带来不同的体验。\n本次试验清味道使用三得利无糖乌龙茶（说不定他帮了同品牌的老牌呢 哈哈\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c5aea50a5cdd79c9e30e8ccf8097ce7f","permalink":"https://blog.morningtzh.com/post/suntoryballantines.html","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/post/suntoryballantines.html","section":"post","summary":"三得利老牌快喝完了，打算醒一段时间再尝一下变化，正好家里有一套百龄坛特醇礼盒，就开了喝。 特醇刚入口，感觉和老牌没什么区别啊，没有像格兰菲迪那","tags":["whisky"],"title":"三得利老牌和百龄坛特醇的对比","type":"post"},{"authors":null,"categories":["reading"],"content":"以前一直在看各种技术相关的书籍或是信息，无聊中也点了django，go，cocos这些类似的技能点。也不知从哪一天开始，越来越厌倦这样技术性的阅读了，技能树越分散其实真正学到的也越少。那既然类似消遣的在学习着，倒也不如看看其他方面的书籍，无论陶冶情操还是看清世界都比技术书籍有用处吧。\n还记得去年这时候也非常迷茫，不知道自己在社会上到底是在一个什么样的层次活着，买了本 戴维·波普诺 的 《社会学》来看，看了版本，还是挺有意思的。但终究敌不过他的厚实，一本只能在家看的书，只看下去了版本。那今年依旧迷茫，就不再追求实体书了吧，能把人打晕的书就不能再买了，看看电子书吧。\n电纸书其实也没什么兴趣，以前买过 Barnes \u0026amp; Noble 的 Nook2， 当然这个已经被我尘封在了书架上，由此也并不想再买一个 kindle 了。\n非常感动的是的我们在一个非常好的时机里面，在 iBook 开始销售电子书后的半年，amazon开启了他在中国的 kindle unlimited 业务，每月固定月费可以免费看几万本垃圾电子书, Holy Shit!!! 这项服务提供的书真是糟糕，更糟糕的是我脑子一热定了半年的。\n于是我开启了 kindle 软件的看书之旅，相较于 iBook 不能同步pdf（ios9.3中已提供了同步），kindle 软件更加好些，并且经过对比也是 amazon 的书更加便宜和全面些。真想吐槽 iBook 书籍的同步速度。这样的模式我也并没有看几本书，不过也好了很多，比起以前的阅读效率，现在更加有些提升了，我还真是阅读电子书更加能沉浸下去，以后书籍方面的投入就会更加倾向电子书了。\n最近看了 《城南旧事》、 《婚姻的故事》、 《第七天》、 《无缘社会》和 《富爸爸穷爸爸》前三本略有些压抑，而后两本则切切实实的带来了恐惧，我从小就有强烈的危机感，这两本书简直又是当头棒喝，告诉了我『你的危机感是真实存在的，不早去控制可能存在的风险，将会活的生不如死』。我很感谢在刚刚踏入社会一年多的时间里看到了这两本书，不早也不晚。太早了就不会有感觉，太晚了就更难挽回局面了。\n其实本来这一篇想写的就是阅读感悟，奈何废话过多变成了说最近的阅读方式了，那么阅读感悟自然需要另起一篇了。即将到来————\n 《生不如死有多遥远》 ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"689110e6ef1a7f4aa4399faac9f679bb","permalink":"https://blog.morningtzh.com/post/reading-mode.html","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/post/reading-mode.html","section":"post","summary":"以前一直在看各种技术相关的书籍或是信息，无聊中也点了django，go，cocos这些类似的技能点。也不知从哪一天开始，越来越厌倦这样技术性的阅读了，技能树越分散其实真正学到的也越少。那既然类似消遣的在学习着，倒也不如看看其他方面的书籍，无论陶冶情操还是看清世界都比技术书籍有用处吧。\n","tags":["reading"],"title":"最近的阅读方式","type":"post"}]